\documentclass[a4paper, 10pt]{article}
\hyphenpenalty=8000
\textwidth=125mm
\textheight=185mm

\usepackage{graphicx}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{fancyvrb}
\usetikzlibrary{matrix,fit}

\usepackage[
  backend=biber,
  style=numeric,
  citestyle=numeric,
  date=iso,
  defernumbers=true
]{biblatex}

\usepackage{hyperref}

\DeclareFieldFormat{labelnumber}{%
  \iffieldundef{shorthand}
    {#1}
    {\printfield{shorthand}}}

\addbibresource{spec.bib}

\setlength\bibitemsep{1em}

\lstdefinelanguage{arf}{
  sensitive = true,
  keywords={},
  otherkeywords={% Operators
    =, ;, (, ), {, }, ->, <, >, \,, @
  },
  keywords = [2]{
    uint8, uint16, uint32, uint64, int8, int16, int32, int64,
    float32, float64, string, bool, bytes, timestamp,
    package, import, enum, struct, service, stream,
    map, array, optional, @deprecated
  },
  keywordstyle=\color{gray},
  keywordstyle=[2]\color{blue},
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]",
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt,
  framesep=10pt
}

\lstdefinelanguage{meta-arf}{
  sensitive = true,
  keywords={},
  otherkeywords={% Operators
    <, >
  },
  keywords = [2]{},
  keywordstyle=\color{gray},
  keywordstyle=[2]\color{blue},
  numbers=none,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]",
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt,
  framesep=10pt
}

\lstdefinelanguage{plain}{
  sensitive = true,
  keywords={},
  otherkeywords={},
  keywords = [2]{},
  numbers=none,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt,
  framesep=10pt
}

\lstdefinelanguage{arfC}{
  sensitive=true,
  morekeywords={
    auto, break, case, char, const, continue, default, do, double, else,
    enum, extern, float, for, goto, if, inline, int, long, register,
    restrict, return, short, signed, sizeof, static, struct, switch,
    typedef, union, unsigned, void, volatile, while,
    uint8_t, uint16_t, uint32_t, uint64_t,
    int8_t, int16_t, int32_t, int64_t,
    size_t
  },
  morekeywords=[2]{NULL},
  keywordstyle=\color{blue},
  keywordstyle=[2]\color{purple},
  identifierstyle=\color{black},
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]",
  morestring=[b]',
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  framesep=10pt,
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt
}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{\small arf - Another RPC Framework}
\fancyhead[C]{}
\fancyhead[R]{\small Sartori}

\renewcommand{\headrulewidth}{0.4pt}

\newcommand{\secref}[1]{\S~\ref{#1}}

\fancypagestyle{firstpage}{%
  \fancyhf{} % clear
  \fancyhead[L]{}
  \fancyhead[R]{}
  \renewcommand{\headrulewidth}{0pt}
  \fancyfoot[C]{\thepage}
}

\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0pt} % no line above footer (optional)



\pagenumbering{arabic}
\setcounter{page}{1}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\newcommand{\doi}[1]{\href{https://doi.org/#1}{\texttt{https://doi.org/#1}}}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\makeatletter
\newcommand\subsubsubsection{%
  \@startsection{paragraph}{4}{\z@}%
    {2.5ex \@plus 1ex \@minus .25ex}%
    {1.25ex \@plus .25ex}%
    {\normalfont\normalsize\bfseries}%
}
\newcommand\subsubsubsubsection{%
  \@startsection{subparagraph}{5}{\z@}%
    {2.5ex \@plus 1ex \@minus .25ex}%
    {1.25ex \@plus .25ex}%
    {\normalfont\normalsize\bfseries}%
}
\makeatother

\begin{document}

\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}}

\thispagestyle{firstpage}

\begin{center}
\LARGE
\textbf{arf - Another RPC Framework}\\[6pt]
\small
\textbf {Vito Sartori, November 2025}\\[6pt]
\vskip 25mm
\end{center}

\begin{abstract}
  The Another RPC Framework (stylized \texttt{arf}) defines an interface description language (IDL),
  a compact binary serialization format, and a request/response protocol for service-oriented communication.

  arf aims to provide a simple, evolvable, and highly efficient system for defining structs, services, and
  RPC methods while eliminating the need for field numeric identifiers in IDL source files. arf emphasizes
  readability, forward compatibility, and minimal over-the-wire footprint.

\vskip 2mm

\end{abstract}

\pagebreak

\section{Status of This Memo}

  This document is an Internet-Draft and is submitted in full conformance with the provisions of BCP 78
  and BCP 79.

  Internet-Drafts are working documents of the Internet Engineering Task Force (IETF). They are draft
  documents valid for a maximum of six months and may be updated, replaced, or obsoleted at any time.

\section{Copyright Notice}

  \begin{flushleft}
  Copyright \copyright\ 2025 Vito Sartori. All rights reserved.
  \end{flushleft}

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

  arf (Another RPC Framework) is a compact, binary, schema-first RPC mechanism designed for
  service-oriented systems. arf provides:

  \begin{itemize}
    \item A simple IDL with packages, imports, structs, and services.
    \item Efficient binary encoding without field tags on the wire.
    \item Optional types without nested “option” wrappers.
    \item Evolvability through package-level versioning.
    \item Re-openable service definitions for modular organization.
  \end{itemize}

  arf draws inspiration from Protobuf, Cap’n Proto, and Thrift while focusing on ergonomics and
  avoiding field-ID management clutter.


\section{Conventions and Terminology}

  The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT,
  RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this document are to be
  interpreted as described in \cite{RFC2119} and \cite{RFC8174} when, and only when, they
  appear in all capitals.

  \subsubsection{Terms}

    \begin{description}
      \item[Client] The endpoint that initiates an RPC by sending an
        \texttt{INVOKE} frame.

      \item[Server] The endpoint that receives an \texttt{INVOKE} frame
        and executes the corresponding method.

      \item[Endpoint] Either the client or the server participating in an
        RPC.

      \item[RPC] A single remote procedure call identified by one
        \texttt{CorrelationID} and consisting of an \texttt{INVOKE} frame
        and any subsequent frames that share that identifier.

      \item[Frame] A discrete protocol message sent over the underlying
        transport representing an invocation, stream element, or control
        signal, as defined in Section~\ref{sec:frame-format}.

      \item[CorrelationID] The identifier that associates all frames
        belonging to the same RPC on a given connection.

      \item[Active RPC] An RPC for which an \texttt{INVOKE} frame has been sent
        and for which the RPC completion conditions defined in Section~\ref{sec:rpc-completion}
        have not yet been satisfied.

      \item[Unary] A non-streaming RPC parameter or result, serialized as
        a single value rather than as a sequence.

      \item[Stream] A potentially unbounded sequence of values of a given
        type, carried using \texttt{IN\_STREAM}/\texttt{IN\_CLOSE} or
        \texttt{OUT\_STREAM}/\texttt{OUT\_CLOSE} frames.

      \item[Input stream] A stream of values flowing from client to
        server as part of an RPC.

      \item[Output stream] A stream of values flowing from server to
        client as part of an RPC.

      \item[Form] One of the sixteen method signature combinations
        defined in Section~\ref{RPC-MethodForms}, derived from the
        presence or absence of unary input, unary output, input stream,
        and output stream.

      \item[Struct] A user-defined composite type consisting of a fixed
        sequence of named fields.

      \item[Field] A named component of a struct, identified for
        serialization by its ordinal position within the struct
        declaration.

      \item[Optional field] A struct field whose type is
        \texttt{optional<T>}, whose presence or absence is indicated by
        the struct’s presence bitmap.

      \item[Package] A named collection of type and service declarations
        that forms a versioned namespace boundary, as defined in
        Section~\ref{sec:packages}.

      \item[Service] A named collection of RPC methods defined within a
        package.

      \item[Method] A single RPC operation defined within a service,
        identified by its name and method form.

      \item[VarUInt] The variable-length unsigned integer encoding used
        for lengths and similar quantities, as defined in
        Section~\ref{sec:length-encoding}.

      \item[Unix Epoch] The time origin defined as \texttt{1970-01-01T00:00:00Z}
        in Coordinated Universal Time (UTC), from which arf timestamps measure
        elapsed milliseconds.
    \end{description}

\section{The arf Language}

  \subsection{Packages}
  \label{sec:packages}

    An arf source file MUST begin with a \texttt{package} declaration:

    \begin{figure}[htb]
      \lstinputlisting[language=arf,firstnumber=1]{package.arf}
    \end{figure}

    Package names establish namespace boundaries and versioning domains.  A
    package name uniquely identifies all types and services defined within
    the file.  Each type defined in a package is assigned a fully-qualified
    name of the form:

    \begin{lstlisting}[language=meta-arf,firstnumber=1]
<package-name> "." <type-name>
    \end{lstlisting}

    Example:

    \begin{lstlisting}[language=plain]
v1beta1.mypackage.OtherName
    \end{lstlisting}

  \subsection{Imports}

      A source file MAY include one or more \texttt{import} directives that
      logically incorporate definitions from other arf source files:

      \lstinputlisting[language=arf,firstnumber=1]{import.arf}

      Each imported file MUST contain a \texttt{package} declaration. The
      package name of the imported file determines the fully-qualified names
      of the types it defines.

      An import MAY specify an explicit local alias using the \texttt{as}
      keyword. If no alias is provided, the compiler MUST derive an implicit
      alias from the final component of the imported package name.

      All aliases within a single source file MUST be unique. If two imports
      would produce the same implicit alias, or if an implicit alias collides
      with an explicit alias, the compiler MUST reject the source file.

      Referenced types of the form \texttt{<alias>.<TypeName>} MUST resolve
      unambiguously to exactly one imported package. Fully-qualified names
      MAY be used instead of aliases and MUST NOT depend on import aliasing.

  \subsection{Types}

    arf provides a set of builtin types that form the foundation of the
    serialization model.  These types MAY appear as struct fields and as
    components of composite types. Builtin primitive types MUST NOT appear
    directly as unary method parameters, unary method results, or stream element
    types.

    \begin{itemize}
      \item \texttt{bool}: a boolean value.
      \item \texttt{int8}, \texttt{int16}, \texttt{int32}, \texttt{int64}:
        signed integers of the specified width.
      \item \texttt{uint8}, \texttt{uint16}, \texttt{uint32}, \texttt{uint64}:
        unsigned integers of the specified width.
      \item \texttt{float32}, \texttt{float64}: IEEE~754 binary floating-point values.
      \item \texttt{string}: a sequence of UTF-8 encoded Unicode scalar values.
      \item \texttt{timestamp}: represents an instant on the UTC time-line encoded as
        an unsigned integer count of milliseconds since the UTC Unix Epoch.
      \item \texttt{bytes}: an arbitrary sequence of octets.
      \item \texttt{array<T>}: an ordered, variable-length sequence of values of type \texttt{T}.
      \item \texttt{map<K, V>}: an unordered, variable-length association between
        keys of type \texttt{K} and values of type \texttt{V}.
      \item \texttt{optional<T>}: a value of type \texttt{T} that MAY be present or absent.
    \end{itemize}

    User-defined \texttt{struct} types MAY also be declared within a package.
    All types, whether builtin or user-defined, participate uniformly in the
    serialization rules described in Section~\ref{sec:serialization}.
    Permitted map key types are:

    \begin{itemize}
      \item any unsigned or signed integer type, and
      \item any \texttt{enum} type.
    \end{itemize}

    All other types are forbidden as map keys.

    Enums are encoded as \texttt{uint16} representing the zero-based ordinal
    position of the enumeration value in the declaration.  Enumeration values
    MUST NOT exceed the range of \texttt{uint16}.

  \subsection{Struct Declarations}
  \label{sec:structs}

    Structs define a sequence of fields, each consisting of a name and a
    type, in the order in which they are written:

    \lstinputlisting[language=arf,firstnumber=1]{struct-decl.arf}

    Field numbers MUST NOT appear in arf source files.  Instead, each field
    is assigned an implicit ordinal index based solely on its position in
    the declaration, beginning at zero for the first field.  Ordinal indices
    MUST remain stable within a package version, as they are referenced by
    the binary serialization rules defined in
    Section~\ref{sec:serialization}.

    Struct declarations MAY include nested struct definitions.  Nested
    structs are assigned fully-qualified names in the same manner as
    top-level structs.

  \subsection{Service Declarations}

    Services define RPC methods:

    \lstinputlisting[language=arf,firstnumber=1]{service-decl.arf}

    Method overloading (multiple methods with the same name but different
    signatures) is not permitted. Method names MUST be unique within a service.

    Each method name MUST be unique within the merged logical service definition
    formed after processing all re-opened service blocks. Multiple declarations
    of the same method name are permitted only when their signatures are identical.

  \subsubsection{Re-Openable Services}

    A service MAY be declared in multiple \texttt{service} blocks within the
    same package. Re-opening a service does not introduce independent scopes.
    All method declarations across blocks participate in a single unified
    namespace:

    \lstinputlisting[language=arf,firstnumber=1]{service-decl-reopen.arf}

    All \texttt{service} blocks with the same service name MUST be merged
    into a single logical service definition during compilation.  If a
    method name appears in more than one block, the compiler MUST determine
    whether the corresponding method signatures are identical.

    Two method declarations are considered to have \emph{identical
    signatures} if and only if all of the following hold:

    \begin{itemize}
      \item They declare the same method name.
      \item They declare the same ordered sequence of unary input parameters.
      \item They declare the same input stream type (or both omit it).
      \item They declare the same ordered sequence of unary output values.
      \item They declare the same output stream type (or both omit it).
    \end{itemize}

    If any of these conditions is violated, the signatures are divergent,
    and the compiler MUST reject the program.

    When a service is declared across multiple \texttt{service} blocks,
    all method names contribute to the same fully-qualified method namespace.
    Duplicate method names across service blocks do not constitute overloading;
    they represent re-declaration and MUST be byte-for-byte equivalent in
    signature.

  \subsubsection{Methods}
    \label{sec:methods}

    An arf method signature consists of zero or more unary input parameters,
    zero or more unary output parameters, and at most one input stream and
    one output stream.  The presence or absence of each of these components
    determines a \emph{method form}.  Four independent boolean dimensions
    are defined:

    \begin{itemize}
      \item \textbf{HasInput}: whether the method declares at least one unary input parameter.
      \item \textbf{HasOutput}: whether the method declares at least one unary output value.
      \item \textbf{HasInputStream}: whether the method declares a single input stream parameter.
      \item \textbf{HasOutputStream}: whether the method declares a single output stream.
    \end{itemize}

    The combination of these four booleans yields sixteen method forms.  Each
    form has a well-defined set of legal frame sequences, as specified in
    Section~\ref{RPC-MethodForms}.

    All unary parameters, unary results, and stream element types MUST be
    defined as either \texttt{struct} or \texttt{enum} types.  Primitive and
    composite types MUST NOT appear directly in RPC method signatures. This
    limitation was deliberately created to ensure all data transmitted through
    RPC methods are part of structures, enforcing all messages to be explicitly
    defined.

  \subsubsection{IDL Syntax for Streams}

    Streams are declared using the \texttt{stream} keyword in either the
    input parameter list or the output tuple.  A method MAY declare at most
    one input stream and at most one output stream.

    Examples:

    \begin{lstlisting}[language=arf]
NNYN(stream T);
NYNY() -> (O, stream U);
YYYY(i I, stream T) -> (O, stream U);
    \end{lstlisting}

    A streaming parameter is written as \texttt{stream <Type>}.  Unary
    parameters are written as standard name--type bindings.  Streams MUST NOT
    appear more than once on either side of the signature.

  \subsection{Fully-Qualified Names}

      Every type and service defined within a package is assigned a
      fully-qualified name of the form:

      \begin{lstlisting}[language=meta-arf,firstnumber=1]
<package-name> "." <identifier>
      \end{lstlisting}

      Fully-qualified names uniquely identify declarations across all
      packages. Two declarations with distinct fully-qualified names are
      considered distinct, even if their unqualified names are identical or
      their definitions are structurally equivalent.

      Within a source file, references to types defined in other packages
      MAY appear in either of the following forms:

      \begin{itemize}
          \item \textbf{Aliased form}: \texttt{<alias>.<TypeName>}, where
              \texttt{<alias>} is the explicit or implicit import alias
                established by an \texttt{import} directive; or
          \item \textbf{Fully-qualified form}: \texttt{<package-name>.<TypeName>}.
      \end{itemize}

      Aliased references MUST resolve unambiguously to exactly one imported
      package. Fully-qualified references MUST NOT depend on import aliasing
      and MUST resolve solely based on the declared package name.

      Fully-qualified names MUST remain stable across all files belonging to
      the same package version. Changing the package name of any declaration
      constitutes a breaking change and therefore requires introducing a new
      package version.

      Methods are assigned fully-qualified names of the form:

      \begin{lstlisting}[language=meta-arf]
<package-name> "." <service-name> "." <method-name>
      \end{lstlisting}

      This string is the canonical method identity used for identifier derivation.

\section{Serialization}
\label{sec:serialization}

  \subsection{Overview}

    arf defines a compact binary serialization format for values of all
    builtin and user-defined types.  Serialization is deterministic and does
    not depend on field names or field numbers appearing in the IDL.  Struct
    fields are serialized in declaration order using implicit ordinal
    indices as described in Section~\ref{sec:structs}.

    All application-level integer \emph{values} (such as field values and
    lengths) are encoded using the \texttt{VarUInt} scheme (and ZigZag +
    \texttt{VarUInt} for signed integers), unless explicitly stated otherwise.
    Floating-point values are encoded in IEEE~754 binary formats using
    little-endian byte order.  Variable-length entities (such as strings,
    byte sequences, arrays, and maps) are prefixed with a length encoded using
    the variable-length integer scheme described in Section~\ref{sec:length-encoding}.

    All serialized representations are self-delimiting and do not require
    out-of-band framing.  The RPC protocol defines its own framing mechanism
    for transporting serialized values.

  \subsection{Length Encoding}
  \label{sec:length-encoding}

    arf uses an unsigned variable-length integer format (referred to in this
    document as \emph{VarUInt}) for encoding lengths of variable-sized
    objects.  VarUInt uses a base-128 continuation-bit scheme:

    \begin{itemize}
      \item Each byte contributes seven bits of payload and one continuation
        bit.
      \item For all but the final byte, the most-significant bit (MSB) MUST
        be set to~1.
      \item The final byte MUST have its MSB set to~0.
    \end{itemize}

    This format allows lengths to be encoded using between one and ten
    bytes, depending on magnitude.  An implementation MUST NOT accept
    lengths that exceed the representational capacity of a 64-bit unsigned
    integer.

    Unless explicitly stated, all length-prefixed types in this section use
    \texttt{VarUInt} for length encoding.

  \subsection{Signed Integer Encoding}
  \label{sec:signed-int-encoding}

    Signed integer values (\texttt{int8}, \texttt{int16}, \texttt{int32},
    \texttt{int64}) are encoded using a two-step process:

    \begin{enumerate}
      \item The signed value is transformed into an unsigned integer using
        ZigZag encoding.
      \item The resulting unsigned integer is serialized using the
        \texttt{VarUInt} scheme defined in Section~\ref{sec:length-encoding}.
    \end{enumerate}

    \subsubsection{ZigZag Transformation}

      ZigZag encoding maps signed integers to unsigned integers such that small
      magnitude values (both positive and negative) produce small unsigned
      values when serialized.  This ensures that numerically small signed values
      compress efficiently under \texttt{VarUInt} encoding.

      For a signed integer value $n$ of bit-width $w$, the ZigZag transform is
      defined as:

\[
z = (n \ll 1) \oplus (n \gg (w - 1))
\]

      Where:
        \begin{itemize}
          \item $\ll$ denotes arithmetic left-shift,
          \item $\gg$ denotes arithmetic right-shift,
          \item $\oplus$ denotes bitwise exclusive OR, and
          \item $w$ is the width of the signed integer type in bits.
        \end{itemize}

      The inverse transformation is defined as:

\[
n = (z \gg 1) \oplus -(z \wedge 1)
\]

    \subsubsection{Width Enforcement}

      Although ZigZag and \texttt{VarUInt} operate on unbounded integers in
      theory, arf enforces strict width limits based on the declared type.

      Decoders \emph{MUST} reject any decoded value whose magnitude exceeds the
      range of the declared signed type:

      \begin{itemize}
        \item \texttt{int8}:      $-128 \le n \le 127$
        \item \texttt{int16}:     $-32{,}768 \le n \le 32{,}767$
        \item \texttt{int32}:     $-2^{31} \le n \le 2^{31}-1$
        \item \texttt{int64}:     $-2^{63} \le n \le 2^{63}-1$
      \end{itemize}

      Encoders \emph{MUST NOT} emit values outside the representable range of
      the declared type.

    \subsubsection{Rationale}

      ZigZag encoding ensures that:

      \begin{itemize}
        \item small negative integers do not expand to large encodings,
        \item signed and unsigned integers share a common storage format,
        \item the encoding is independent of machine endianness, and
        \item integer encodings remain stable across platforms and languages.
      \end{itemize}

      This scheme enables compact representation of signed integers while
      preserving fast decoding and deterministic serialization.


    \subsubsection{Worked Examples}

      The following examples illustrate ZigZag transformation and the resulting
      VarUInt encoding (32-bit width shown for clarity):

      \begin{center}
        \begin{tabular}{rrrr}
          \toprule
          Signed & ZigZag($n$) & Decimal & VarUInt Bytes \\ \midrule
          0      & 0x00        & 0       & \texttt{00}   \\
          -1     & 0x01        & 1       & \texttt{01}   \\
          1      & 0x02        & 2       & \texttt{02}   \\
          -2     & 0x03        & 3       & \texttt{03}   \\
          2      & 0x04        & 4       & \texttt{04}   \\
          300    & 0x0258      & 600     & \texttt{D8 04}\\
          -300   & 0x0257      & 599     & \texttt{D7 04}\\
          \bottomrule
        \end{tabular}
      \end{center}

      For example, for $n = -1$:

\[
z = (-1 \ll 1) \oplus (-1 \gg 31) = 1
\]

      ZigZag(-1) therefore produces \texttt{0x01}, which is encoded as a
      single-byte VarUInt.


    \subsubsection{Mapping Summary (Signed → ZigZag → VarUInt)}

      \begin{center}
        \begin{tabular}{rrr}
          \toprule
          Signed & ZigZag($n$) & VarUInt Encoding \\ \midrule
          0      & 0           & \texttt{00} \\
          -1     & 1           & \texttt{01} \\
          1      & 2           & \texttt{02} \\
          -2     & 3           & \texttt{03} \\
          2      & 4           & \texttt{04} \\
          -3     & 5           & \texttt{05} \\
          3      & 6           & \texttt{06} \\
          300    & 600         & \texttt{D8 04} \\
          -300   & 599         & \texttt{D7 04} \\
          \bottomrule
        \end{tabular}
      \end{center}

  \subsection{Primitive Types}

    The serialization of primitive types is defined as follows:

    \begin{itemize}
      \item \textbf{bool}: encoded as a single byte.  The value \texttt{0x00}
        represents \texttt{false}; the value \texttt{0x01} represents
        \texttt{true}.  No other values are permitted.
      \item \textbf{uint8}, \textbf{uint16}, \textbf{uint32}, \textbf{uint64}:
        encoded as \texttt{VarUInt} (Section~\ref{sec:length-encoding}).  The
        encoded value MUST lie within the range of the corresponding unsigned
        integer type.  Decoders MUST reject values that exceed the representable
        range of the declared type.
      \item \textbf{int8}, \textbf{int16}, \textbf{int32}, \textbf{int64}:
        encoded as a signed variable-length integer using ZigZag encoding
        followed by \texttt{VarUInt}.  Let $n$ be the signed value and $z$ the
        ZigZag-transformed unsigned integer.  Encoders MUST compute $z$ and emit
        it using \texttt{VarUInt}; decoders MUST recover $n$ from $z$ and verify
        that it lies within the range of the declared signed type.
      \item \textbf{float32}, \textbf{float64}: encoded in IEEE~754 binary32
        or binary64 format respectively, using little-endian byte order.
      \item \textbf{string}: encoded as \texttt{VarUInt(length)} followed by
        \texttt{length} bytes containing UTF-8 encoded scalar values.
        Invalid UTF-8 byte sequences MUST cause deserialization to fail.
      \item \textbf{bytes}: encoded as \texttt{VarUInt(length)} followed by
        \texttt{length} raw octets.
      \item \textbf{timestamp}: encoded as \texttt{VarUInt} representing the
        number of milliseconds elapsed since the UTC Unix Epoch.
        Implementations that cannot represent millisecond precision MUST
        truncate toward zero.
    \end{itemize}

    These encodings are used uniformly whether a primitive appears as a
    struct field or within a composite type. However, primitives MUST NOT be
    used as unary method parameters, unary method results, or as stream elements.
    For methods, unary inputs, unary outputs, and streams MUST use structs or
    enums as specified in Section~\ref{sec:methods}.

    Key equality is defined by equality of the serialized key value.

    For integer keys, numeric equality applies.
    For enumeration keys, ordinal equality applies.

    Because structured types are forbidden as keys, equality testing is
    deterministic and implementation-independent.

  \subsection{Composite Types}

    Composite types define container-like structures with their own encoding
    rules.

    \subsubsection{Arrays}

      An \texttt{array<T>} value is encoded as:

      \begin{enumerate}
        \item \texttt{VarUInt(n)}, where $n$ is the number of elements.
        \item The concatenation of the serialized representations of the $n$
          elements in order.
      \end{enumerate}

      An array MAY be empty.  Empty arrays are encoded as \texttt{VarUInt(0)}
      followed by zero bytes.

    \subsubsection{Maps}

      A \texttt{map<K, V>} value is encoded as:

      \begin{enumerate}
        \item \texttt{VarUInt(n)}, where $n$ is the number of key--value pairs.
        \item For each pair, the serialized key immediately followed by the
          serialized value.
      \end{enumerate}

      A map MAY be empty.  Map iteration order MUST be the order chosen by the
      encoder and MUST be preserved by the decoder without implying semantic
      ordering or sorting.

      Keys MUST be unique according to the equality semantics of type
      \texttt{K}.  Deserializers MUST reject maps that contain duplicate keys.

    \subsubsection{Structs}

      Struct values are serialized as \emph{length-prefixed records}.  Each
      struct instance is preceded by a byte length that defines the total
      size of the struct body in bytes, allowing decoders to skip unknown
      fields safely.

      A struct value is encoded as:

      \begin{enumerate}
         \item \texttt{VarUInt(L)}, where $L$ is the number of bytes in the
           struct body that follows; and
         \item the struct body, consisting of the presence bitmap and
           serialized field values as described below.
      \end{enumerate}

      No field numbers or tag identifiers appear on the wire; fields are
      identified solely by their ordinal position within the struct.

      Let a struct contain $m$ fields.  The struct body is encoded as follows:

      \begin{enumerate}
        \item Emit a presence bitmap with \emph{exactly $m$ bits}, encoded in
          whole bytes, least-significant bit first.  The $i$th bit
          corresponds to the $i$th field in declaration order.
          \begin{itemize}
            \item For a non-optional field, the bit \emph{MUST} be set to~1.
            \item For an \texttt{optional<T>} field, the bit is set to~1 if
              the value is present and to~0 if the value is absent.
          \end{itemize}

        \item For each field $i$ in declaration order:
          \begin{itemize}
            \item If the presence bit for field $i$ is~1, serialize the
              value according to the rules for its type.
            \item If the presence bit for field $i$ is~0, no bytes are
              emitted for that field; this case is only legal for
              \texttt{optional<T>} fields.
          \end{itemize}
      \end{enumerate}

      Decoders \emph{MUST} NOT assume knowledge of the physical layout of a
      struct beyond the fields they explicitly recognize.  After decoding the
      fields they understand, implementations \emph{MUST} skip any remaining
      trailing bytes in the struct body as determined by the length prefix.

      Trailing bytes within the struct body are reserved for fields appended
      in later schema versions and MUST be preserved during forwarding or
      re-encoding.

      Because field ordinals define the on-wire layout, implementations
      \emph{MUST NOT} reorder fields within a package version.

  \subsection{Optional Fields}

    An \texttt{optional<T>} value MAY be present or absent.  Optional fields
    in structs use the presence bitmap described above.  Any other type or
    composite type may be used as \texttt{T}.

  \subsection{Error Handling}

    A deserializer MUST reject any of the following:

    \begin{itemize}
      \item malformed VarUInt encodings,
      \item lengths that exceed the remaining buffer,
      \item invalid UTF-8 in \texttt{string} values,
      \item duplicate keys in a \texttt{map<K,V>},
      \item unexpected trailing bytes after a serialized value,
      \item any violation of the structural constraints defined in this section.
    \end{itemize}

    Unless explicitly specified, deserialization errors MUST be treated as
    fatal to the enclosing RPC invocation.

  \subsection{Binary Layout Example}
  \label{sec:layout-example}

    This section provides a concrete example illustrating how arf encodes structs and
    how length-prefixing enables safe evolution.

    Consider the following initial struct definition:

    \begin{lstlisting}[language=arf]
struct User {
    id   uint32;
    name string;
}
    \end{lstlisting}

    This struct contains two fields.  A serialized instance is encoded as:

    \begin{center}
      \begin{tabular}{ll}
        \toprule
        Component & Description \\
        \midrule
        VarUInt(L) & Length of the struct body in bytes \\
        Bitmap    & 2 bits indicating presence of fields \\
        Field 0   & \texttt{id} (uint32) \\
        Field 1   & \texttt{name} (string) \\
        \bottomrule
      \end{tabular}
    \end{center}

    Assume an evolution where a new optional field is appended:

    \begin{lstlisting}[language=arf]
struct User {
    id    uint32;
    name  string;
    email optional<string>;
}
    \end{lstlisting}

    The new binary layout becomes:

    \begin{center}
      \begin{tabular}{ll}
        \toprule
        Component & Description \\
        \midrule
        VarUInt(L') & New struct body length \\
        Bitmap     & 3 bits (one for each field) \\
        Field 0    & \texttt{id} \\
        Field 1    & \texttt{name} \\
        Field 2    & \texttt{email} (if present) \\
        \bottomrule
      \end{tabular}
    \end{center}

    When an older receiver (that only knows the two-field layout) decodes this value,
    it proceeds as follows:

    \begin{itemize}
      \item It reads \texttt{VarUInt(L')} and learns the total size of the struct body.
      \item It decodes only the fields it recognizes (the first two).
      \item It skips the remaining bytes using the length prefix.
    \end{itemize}

    Because all struct values are length-delimited, receivers never need to
    understand the internal layout of unknown fields in order to skip them safely.
    This guarantees forward compatibility for nested structs, arrays of structs, and
    arbitrarily complex type graphs.


\section{RPC Protocol}
\label{sec:rpc-protocol}

  arf defines a bidirectional message-oriented protocol used to transport
  serialized request and response values between a client and a server.
  This section defines the framing model, identifier space, message
  semantics, and the legal frame sequences for each method form defined in
  Section~\ref{RPC-MethodForms}.

  Unless otherwise noted, all multi-byte integer fields are encoded in
  little-endian byte order.  All frames are self-contained and do not rely
  on lower-layer segmentation semantics.

  \subsection{Frame Format}
  \label{sec:frame-format}

    Each message exchanged between a client and server is encoded as an arf
    \emph{frame}.  Frames MUST NOT be fragmented or interleaved at the byte
    level.  The format of a frame is:

    \begin{center}
      \begin{tabular}{@{}ll@{}}
        \toprule
          Field         & Description \\ \midrule
          Magic[2]        & Fixed value \texttt{0xAF 0x01} identifying arf framing. \\
          Version[1]        & Protocol version.  This document specifies version~1. \\
          MessageKind[1]      & Indicates the semantic type of the frame. \\
          Flags[1]        & Reserved for future use; MUST be zero for version~1. \\
          PackageID[4]      & Identifier for the package containing the service. \\
          ServiceID[4]      & Identifier for the service. \\
          MethodID[4]       & Identifier for the method. \\
          CorrelationID[8]    & Opaque identifier linking frames belonging to the same RPC. \\
          PayloadLength (var)   & Length of the payload using VarUInt encoding. \\
          Payload (var)     & Serialized value according to Section~\ref{sec:serialization}. \\
        \bottomrule
      \end{tabular}
    \end{center}

    All frames MUST begin with the 2-byte magic value.  Receivers MUST treat
    a mismatched magic value as a framing error and close the connection.

    \paragraph{MessageKind}

      The \texttt{MessageKind} byte MUST be one of the following:

      \begin{center}
        \begin{tabular}{@{}ll@{}}
          \toprule
            Value & Meaning \\ \midrule
            0x01  & \texttt{INVOKE}: initiates an RPC call. \\
            0x02  & \texttt{IN\_STREAM}: element of an input stream. \\
            0x03  & \texttt{IN\_CLOSE}: signals end of input stream. \\
            0x04  & \texttt{OUT\_STREAM}: element of an output stream. \\
            0x05  & \texttt{OUT\_CLOSE}: signals end of output stream. \\
            0x06  & \texttt{RESPONSE}: unary output payload. \\
            0x07  & \texttt{ERROR}: terminal error. \\
            0x08  & \texttt{CANCEL}: client cancellation of the RPC. \\
          \bottomrule
        \end{tabular}
      \end{center}

    \subsection{Transport Assumptions}
    \label{sec:transport-assumptions}

      arf is designed to run over a reliable, ordered, bidirectional transport.
      The transport MUST preserve byte order and MUST NOT duplicate or reorder
      bytes.  Examples of suitable transports include TCP connections, QUIC
      streams, and Unix domain sockets.

      arf frames, as defined in Section~\ref{sec:frame-format}, are logical
      protocol units and do not necessarily correspond to transport-level
      segments.  Endpoints MUST be able to reconstruct frames from an
      arbitrary segmentation of the underlying byte stream.

      Datagram-oriented transports (such as bare UDP) do not satisfy these
      requirements without additional reliability and ordering mechanisms.
      Such mechanisms are out of scope for this specification.

    \subsection{Connection Model and Multiplexing}
    \label{sec:multiplexing}

      arf is designed to support multiplexing of multiple RPCs over a single
      transport connection.  A connection is viewed as a bidirectional stream
      of frames as defined in Section~\ref{sec:frame-format}.

      \subsubsection{Correlation Identifiers}

        The \texttt{CorrelationID} field in each frame identifies the logical
        RPC to which the frame belongs.  The following rules apply:

        \begin{itemize}
          \item For a given connection, the client MUST choose a
            \texttt{CorrelationID} that is not currently active when
            initiating a new RPC.

          \item An RPC becomes active when its \texttt{INVOKE} frame is sent.
            It remains active until the RPC completion conditions defined in
            Section~\ref{sec:rpc-completion} are satisfied.

          \item Once an RPC has completed, its \texttt{CorrelationID} MAY be
            reused for a subsequent RPC on the same connection.
        \end{itemize}

        Implementations MUST treat the receipt of frames for an unknown or
        inactive \texttt{CorrelationID} (that is, a \texttt{CorrelationID} for
        which no active RPC exists) as a protocol error.

      \subsubsection{Concurrent RPCs}

        Clients MAY initiate multiple RPCs concurrently over the same
        connection by sending multiple \texttt{INVOKE} frames with distinct
        \texttt{CorrelationID} values.  Similarly, servers MAY process multiple
        RPCs concurrently and interleave frames for those RPCs arbitrarily.

        For each individual \texttt{CorrelationID}, the following invariants
        MUST hold:

        \begin{itemize}
          \item Exactly one \texttt{INVOKE} frame MUST appear, and it MUST be
            the first frame for that \texttt{CorrelationID}.

          \item All subsequent frames with that \texttt{CorrelationID} MUST
            conform to the method form and sequencing rules defined in
            Section~\ref{RPC-MethodForms}.

          \item Once the RPC completion conditions defined in
            Section~\ref{sec:rpc-completion} have been satisfied,
            endpoints MUST treat the \texttt{CorrelationID} as inactive and
            MUST NOT send further frames for that \texttt{CorrelationID}.
        \end{itemize}

        Frames belonging to different \texttt{CorrelationID} values MAY be
        arbitrarily interleaved in both directions, subject to any flow-control
        or prioritization policies implemented by the endpoints.

    \subsubsection{Ordering Guarantees}

      The transport MUST preserve byte order, and endpoints MUST preserve the
      frame order in which data is received.  As a consequence:

      \begin{itemize}
        \item For a given \texttt{CorrelationID}, the sequence of frames is
          strictly ordered and can be processed in order.
        \item No ordering guarantees are provided between frames belonging to
          different \texttt{CorrelationID} values beyond those implied by
          the underlying transport.
      \end{itemize}

      arf does not define fairness or prioritization between concurrent RPCs.
      Such policies are implementation-specific and MAY be influenced by
      application-level considerations.

  \subsection{Identifiers}
  \label{sec:identifiers}

    PackageID, ServiceID, and MethodID are 32-bit unsigned integers derived
    from the fully-qualified names of packages, services, and methods using
    the FNV-1a hash function. The hash function MUST be implemented exactly
    as specified in this section; all conforming implementations MUST
    produce identical identifiers for the same fully-qualified name.

    The identifier derivation scheme is intentionally opaque in arf source
    files and MUST NOT be user-configurable.  Identifiers MUST remain
    stable for the lifetime of a package version.  Changing any identifier
    constitutes a breaking change requiring a new package version.

    \subsubsection{FNV-1a Hash Function}

        arf derives \texttt{PackageID}, \texttt{ServiceID}, and \texttt{MethodID}
        values using the FNV-1a non-cryptographic hash function operating on
        32-bit unsigned integers.  FNV-1a is selected for its simplicity,
        determinism, efficiency, and well-defined behavior across
        implementations.

        The FNV-1a algorithm MUST be implemented exactly as specified in this
        section.  All conforming implementations MUST produce identical hash
        outputs for the same input byte sequence.

        The hash function operates over a sequence of octets and produces a
        single 32-bit unsigned integer.  Arithmetic is performed using unsigned
        32-bit modular arithmetic with wraparound on overflow.

        FNV-1a is not a cryptographic hash function and MUST NOT be used for
        security-sensitive purposes such as message authentication,
        integrity verification, or identity proof.  Its sole purpose in arf is
        deterministic identifier derivation.

        The domain of the input to the hash function is restricted and
        well-defined.  Implementations MUST apply namespace-specific prefixes
        prior to hashing to ensure that identifiers for different kinds of
        entities do not collide.  The input to the hash function for each
        identifier is defined as follows:

        \begin{itemize}
            \item \textbf{PackageID} is derived from:
              \texttt{"pkg:" || <package-fqn>}
            \item \textbf{ServiceID} is derived from:
              \texttt{"svc:" || <service-fqn>}
            \item \textbf{MethodID} is derived from:
              \texttt{"method:" || <package> "." <service> "." <method>}
        \end{itemize}

        The fully-qualified name strings MUST be encoded as UTF-8 prior to
        hashing, without terminating null bytes or additional normalization.

        Collisions MUST be detected at compile time.  If two distinct
        fully-qualified names produce the same identifier within the same
        identifier space (package, service, or method), the compiler MUST
        reject the program.  Implementations MUST NOT accept such collisions
        silently.

        Implementations MUST treat the input byte stream as an ordered sequence of
      octets.  No Unicode normalization, case-folding, or locale-sensitive
      transformation is permitted.

        The normative description and reference implementation of the FNV-1a
        algorithm appear below.

        \begin{lstlisting}[language=plain]
FNV-1a-32(input):

  Let offset_basis = 2166136261 (0x811C9DC5).
  Let FNV_prime    = 16777619   (0x01000193).

  Let h = offset_basis.
  For each byte b in input, in order:
      h = h XOR b
      h = (h * FNV_prime) mod 2^32

  Return h.
        \end{lstlisting}

        A C reference implementation and test vectors are provided
      in \hyperref[annex:a]{Appendix A} and \hyperref[annex:b]{Appendix B},
      respectively.



  \subsection{Requests}
  \label{sec:requests}

    An RPC request is initiated by the client sending an \texttt{INVOKE}
    frame.  The payload of the \texttt{INVOKE} frame depends on the method
    form:

    \begin{itemize}
      \item If \textbf{HasInput} is true, the payload MUST contain the
        serialization of the unary input struct.
      \item If \textbf{HasInput} is false, the payload MUST be empty.
      \item If \textbf{HasInputStream} is true, the input stream is
        considered open immediately after the \texttt{INVOKE} frame.  The
        client MAY send zero or more \texttt{IN\_STREAM} frames, followed
        by exactly one \texttt{IN\_CLOSE}.
    \end{itemize}

    A client MUST NOT send additional \texttt{INVOKE} frames with the same
    \texttt{CorrelationID}.  Doing so constitutes a protocol error.

    \subsection{Method Forms and Allowed Frame Sequences}
    \label{RPC-MethodForms}

      arf defines sixteen distinct \emph{method forms}, derived from the
      presence or absence of: (1) unary input parameters, (2) unary output
      values, (3) an input stream, and (4) an output stream.  The four-letter
      form label encodes the booleans \texttt{HasInput}, \texttt{HasOutput},
      \texttt{HasInputStream}, and \texttt{HasOutputStream}, respectively,
      using \texttt{Y} for ``present'' and \texttt{N} for ``absent''.

      Table~\ref{tab:method-forms} specifies, for each form, whether the
      client and server MAY send the streaming frame kinds defined in
      Section~\ref{sec:frame-format}.  Frames belonging to different
      \texttt{CorrelationID} values MAY be arbitrarily interleaved on the same
      connection, as described in Section~\ref{sec:multiplexing}.

      \begin{table}[htb]
        \centering
        \caption{arf Method Forms and Permitted Streaming Frames (per \texttt{CorrelationID})}
        \label{tab:method-forms}
        \begin{tabular}{lcccccccc}
          \toprule
          Form &
          HasIn &
          HasOut &
          HasInS &
          HasOutS &
          C:IS &
          C:IC &
          S:OS &
          S:OC \\
          \midrule
          NNNN & N & N & N & N & N & N & N & N \\
          NNNY & N & N & N & Y & N & N & Y & Y \\
          NNYN & N & N & Y & N & Y & Y & N & N \\
          NNYY & N & N & Y & Y & Y & Y & Y & Y \\
          NYNN & N & Y & N & N & N & N & N & N \\
          NYNY & N & Y & N & Y & N & N & Y & Y \\
          NYYN & N & Y & Y & N & Y & Y & N & N \\
          NYYY & N & Y & Y & Y & Y & Y & Y & Y \\
          YNNN & Y & N & N & N & N & N & N & N \\
          YNNY & Y & N & N & Y & N & N & Y & Y \\
          YNYN & Y & N & Y & N & Y & Y & N & N \\
          YNYY & Y & N & Y & Y & Y & Y & Y & Y \\
          YYNN & Y & Y & N & N & N & N & N & N \\
          YYNY & Y & Y & N & Y & N & N & Y & Y \\
          YYYN & Y & Y & Y & N & Y & Y & N & N \\
          YYYY & Y & Y & Y & Y & Y & Y & Y & Y \\
          \bottomrule
        \end{tabular}
      \end{table}

      \noindent
      Legend:

      \begin{itemize}
        \item HasIn  = HasInput
        \item HasOut = HasOutput
        \item HasInS = HasInputStream
        \item HasOutS = HasOutputStream
        \item C:IS = client MAY send \texttt{IN\_STREAM}
        \item C:IC = client MAY send \texttt{IN\_CLOSE}
        \item S:OS = server MAY send \texttt{OUT\_STREAM}
        \item S:OC = server MAY send \texttt{OUT\_CLOSE}
      \end{itemize}

      For each form, the following additional constraints apply, per
      \texttt{CorrelationID}:

      \begin{itemize}
        \item Exactly one \texttt{INVOKE} frame MUST be sent, and it MUST be
          the first frame.
        \item If HasInS is \texttt{Y}, the client MAY send zero or more
          \texttt{IN\_STREAM} frames followed by exactly one
          \texttt{IN\_CLOSE}.  If HasInS is \texttt{N}, the client MUST
          NOT send \texttt{IN\_STREAM} or \texttt{IN\_CLOSE}.
        \item If HasOutS is \texttt{Y}, the server MAY send zero or more
          \texttt{OUT\_STREAM} frames followed by exactly one
          \texttt{OUT\_CLOSE}.  If HasOutS is \texttt{N}, the server MUST
          NOT send \texttt{OUT\_STREAM} or \texttt{OUT\_CLOSE}.
      \end{itemize}

    \subsubsection{RPC Completion}
    \label{sec:rpc-completion}

      For a given \texttt{CorrelationID}, an RPC is considered complete
      when one of the following conditions holds:

      \begin{itemize}
        \item An \texttt{ERROR} frame has been received, or
        \item A \texttt{CANCEL} frame has been received, or
        \item A \texttt{RESPONSE} frame has been received and all streams
          declared by the method form have been closed:
          \begin{itemize}
            \item if \textbf{HasInputStream} is \texttt{true}, an
              \texttt{IN\_CLOSE} frame has been received; and
            \item if \textbf{HasOutputStream} is \texttt{true}, an
              \texttt{OUT\_CLOSE} frame has been received.
          \end{itemize}
      \end{itemize}

      Once any of the above conditions is satisfied, endpoints MUST treat
      the \texttt{CorrelationID} as inactive and MUST NOT send further
      frames with that \texttt{CorrelationID}.

  \subsection{Interleaving of Input and Output Streams}

    For method forms that declare both an input stream and an output
    stream (i.e., \textbf{HasInputStream} = true and
    \textbf{HasOutputStream} = true), the client and server MAY send
    \texttt{IN\_STREAM} and \texttt{OUT\_STREAM} frames in any order,
    including arbitrarily interleaved.  Neither endpoint is required to
    await stream activity from the peer before sending additional
    elements.

    Stream directions are independent: the client MAY continue sending
    input elements regardless of whether the server is actively sending
    output elements, and vice versa.

  \subsection{Unary vs Streaming Semantics}

    \subsubsection{Unary Input}
      If \textbf{HasInput} is true, the \texttt{INVOKE} payload MUST contain a
      serialized unary input struct.  If false, the payload MUST be empty.

    \subsubsection{Input Stream}
      If \textbf{HasInputStream} is true:

      \begin{itemize}
        \item The client MAY send zero or more \texttt{IN\_STREAM} frames.
        \item Each \texttt{IN\_STREAM} frame MUST contain exactly one serialized
          element of the declared input stream type.
        \item The client MUST send exactly one \texttt{IN\_CLOSE}.
        \item After \texttt{IN\_CLOSE}, no further inbound stream frames are
          permitted.
      \end{itemize}

    \subsubsection{Unary Output}

      For every RPC that completes successfully (that is, does not terminate
      with an \texttt{ERROR} frame), the server MUST send exactly one
      \texttt{RESPONSE} frame for the corresponding \texttt{CorrelationID},
      regardless of whether the method declares no unary outputs, one or more
      unary outputs, an output stream, or any combination thereof.

      The \texttt{RESPONSE} frame MUST be the first application-level
      frame sent by the server for that \texttt{CorrelationID}.  In
      particular, the server MUST NOT send any \texttt{OUT\_STREAM} or
      \texttt{OUT\_CLOSE} frames before the \texttt{RESPONSE} frame.

      If \textbf{HasOutput} is \texttt{true}, the payload of the
      \texttt{RESPONSE} frame MUST contain the serialized unary output
      struct or tuple.  If \textbf{HasOutput} is \texttt{false}, the payload
      of the \texttt{RESPONSE} frame MUST be empty.

    \subsubsection{Unary Output Ordering}

      For all method forms in which \textbf{HasOutput} is true, the server
      MUST send the \texttt{RESPONSE} frame before transmitting any
      \texttt{OUT\_STREAM} frames.  Once \texttt{RESPONSE} has been sent,
      the server MAY interleave \texttt{OUT\_STREAM} frames with incoming
      \texttt{IN\_STREAM} frames arbitrarily.

    \subsubsection{Output Stream}

      If \textbf{HasOutputStream} is \texttt{true}, the server MAY produce an
      output stream \emph{after} sending the \texttt{RESPONSE} frame.

      In that case, the following rules apply for the given
      \texttt{CorrelationID}:

      \begin{itemize}
        \item The server MAY send zero or more \texttt{OUT\_STREAM} frames.
        \item Each \texttt{OUT\_STREAM} frame MUST contain exactly one
          serialized element of the declared output stream type.
        \item The server MUST send exactly one \texttt{OUT\_CLOSE} frame to
          indicate the end of the output stream.
        \item The server MUST NOT send any \texttt{OUT\_STREAM} or
          \texttt{OUT\_CLOSE} frames before the \texttt{RESPONSE} frame.
        \item After sending \texttt{OUT\_CLOSE}, the server MUST NOT send any
          further \texttt{OUT\_STREAM} or \texttt{OUT\_CLOSE} frames for
          that \texttt{CorrelationID}.
      \end{itemize}

      Thus, for methods with \textbf{HasOutputStream} set to \texttt{true},
      the canonical successful server-side sequence (ignoring input frames)
      is:

      \begin{lstlisting}[language=plain]
RESPONSE
OUT_STREAM*   // zero or more times
OUT_CLOSE
      \end{lstlisting}

  \subsection{Per-form Examples}

    This subsection provides illustrative but non-normative examples of
    legal frame sequences for selected method forms.  Let \texttt{CID} be a
    CorrelationID.

    \subsubsection{Form: NNNN (no input, no output, no streams)}

      \begin{lstlisting}[language=plain]
INVOKE(CID)
RESPONSE(CID)
      \end{lstlisting}

    \subsubsection{Form: NNNY (server-streaming only)}

      \begin{lstlisting}[language=plain]
INVOKE(CID)
RESPONSE(CID)
OUT_STREAM(CID)
OUT_STREAM(CID)
OUT_CLOSE(CID)
      \end{lstlisting}

    \subsubsection{Form: YNYN (unary input, input stream, no unary output)}

      \begin{lstlisting}[language=plain]
INVOKE(CID, unary-input)
RESPONSE(CID)   // empty response
IN_STREAM(CID, T)
IN_STREAM(CID, T)
IN_CLOSE(CID)
      \end{lstlisting}

    \subsubsection{Form: YYYY (full bidirectional streaming + unary input/output)}


      \begin{lstlisting}[language=plain]
INVOKE(CID, unary-input)
IN_STREAM(CID, T)
IN_STREAM(CID, T)
IN_CLOSE(CID)

RESPONSE(CID, unary-output)

OUT_STREAM(CID, U)
OUT_STREAM(CID, U)
OUT_CLOSE(CID)
      \end{lstlisting}


  \subsection{Cancellation and Error Semantics}

    A client MAY abort an ongoing RPC using a \texttt{CANCEL} frame with the
    same \texttt{CorrelationID} as the active call.  Upon receiving
    \texttt{CANCEL}, the server:

    \begin{itemize}
      \item MUST cease sending further frames for that \texttt{CorrelationID},
      \item MAY release any associated resources immediately,
      \item MAY send an \texttt{ERROR} frame if additional diagnostic
        information is available.
    \end{itemize}

    A server MAY emit an \texttt{ERROR} frame at any time to signal an
    irrecoverable condition.  Upon receiving \texttt{ERROR}, the client MUST
    treat the RPC as terminated and MUST NOT send additional frames for that
    \texttt{CorrelationID}.

  \subsection{Backpressure}

    arf does not define a mandatory flow-control mechanism.  Implementations
    SHOULD apply backpressure using transport-level or application-level
    means.  Implementations MUST remain robust in the presence of senders
    that produce data more rapidly than the receiver can process.

    Extensions to provide explicit credit-based flow control MAY be defined
    in future versions of this specification.

\section{Evolution and Compatibility}
\label{sec:evolution}

  arf is designed to permit incremental schema evolution without requiring
  explicit field identifiers in source files.  Compatibility is achieved by
  combining stable field ordinals with length-prefixed struct encoding, allowing
  new fields to be added while preserving the ability of older implementations to
  safely skip unknown data.

  The rules in this section govern how types may change across package versions
  while maintaining compatibility at the binary level.

  \subsection{Adding Fields}

    New fields MAY be appended to the end of an existing struct.  Because field
    ordinal indices are defined by declaration order, appending a field assigns it
    the next available ordinal.  Existing ordinals MUST NOT change.

    Struct values are length-prefixed as defined in
    Section~\ref{sec:serialization}.  As a result, receivers MUST skip any trailing
    bytes in the struct body beyond the fields they recognize.  This allows new
    fields to be introduced in a backward-compatible and forward-compatible manner.

    Senders MAY include newly added fields when communicating with older receivers;
    older receivers MUST ignore trailing bytes safely.  Likewise, senders MAY omit
    fields not known to the peer.

    New fields SHOULD be declared as \texttt{optional<T>} unless the semantics
    require mandatory presence.  Using \texttt{optional<T>} maximizes flexibility
    and minimizes compatibility risk.

  \subsection{Removing Fields}

    Fields MUST NOT be removed from a struct in a way that changes the ordinal
    position of any remaining field.  Instead, fields that are no longer used SHOULD
    be marked with the \texttt{@deprecated} attribute and retained with their
    original ordinal position.

    Senders SHOULD omit deprecated fields when serializing.  Receivers MUST accept
    and ignore deprecated fields if they appear.

    If a field must be fully removed (such that its ordinal becomes invalid), this
    MUST be done only by introducing a new package version (see
    Section~\ref{sec:versioning}).  No cross-package compatibility is required.

  \subsection{Changing Types}

    A field's type MUST NOT change within the same package version.  Any modification
    to a field's type—including widening (e.g., \texttt{int32} to \texttt{int64}),
    narrowing, or structural change—constitutes a backward-incompatible change.

    Type changes MUST be performed only by introducing a new package version.

    Changing a field from a concrete type to \texttt{optional<T>} within the same
    package version is permitted only if:
    \begin{itemize}
      \item the wire encoding is identical when the value is present, and
      \item receivers can safely interpret the absence of the value as ``not present''.
    \end{itemize}

    Changing a field from \texttt{optional<T>} to a non-optional type is not
    compatible and MUST NOT be performed within the same package version.

  \subsection{Versioning Through Packages}
  \label{sec:versioning}

    arf relies on the \texttt{package} namespace as the primary unit of
    versioning.  A change that violates any of the compatibility rules in
    this section MUST be introduced under a new package name.

    Package names SHOULD include a stability level (e.g.,
    \texttt{v1beta1}, \texttt{v1}, \texttt{v2}) to provide clear evolution
    points.  Implementations MAY simultaneously support multiple package
    versions.

    No cross-package binary compatibility is required or implied.  Changes
    within a package version MUST adhere to the evolution rules above.

\section{ABNF Grammar}

  This section provides the normative syntax of the arf source language,
  expressed using Augmented Backus–Naur Form (ABNF) as defined in
  RFC~5234 and RFC~7405.  ABNF rules specify the lexical and syntactic
  structure of valid arf source files.  The grammar below is complete
  for this specification.

\begin{quote}
  \small
  \VerbatimInput{grammar.abnf}
\end{quote}

\section{Security Considerations}

  arf describes a serialization format and an RPC protocol but does not
  mandate any particular transport security mechanism.  When deployed over
  an untrusted network, implementations MUST provide confidentiality,
  integrity, and endpoint authentication using a transport such as TLS \cite{RFC8446},
  QUIC \cite{RFC9000} with TLS 1.3 \cite{RFC9001}, or an equivalent secure channel.

  Endpoints MUST validate that incoming frames conform to the arf framing
  rules, including length fields, frame ordering constraints, and stream
  termination semantics.  Malformed or truncated frames MUST result in
  termination of the associated \texttt{CorrelationID} and SHOULD result
  in connection closure.

  Implementations MUST impose limits on:
  \begin{itemize}
    \item maximum frame length,
    \item maximum number of concurrent \texttt{CorrelationID} streams,
    \item maximum nesting depth for type decoding,
    \item maximum aggregate memory per connection.
  \end{itemize}

  These limits prevent resource exhaustion attacks.

  Optional fields and variable-length structures (arrays, maps, byte
  sequences) MUST be validated before allocation.  Implementations MUST
  reject encodings that imply unreasonable memory commitments.

  Method names, package names, and type names are not security boundaries.
  Applications MAY impose authorization checks based on method identity,
  but such checks are outside the scope of this specification.

  Applications that embed sensitive data in arf messages MUST consider
  application-level encryption or tokenization if end-to-end confidentiality
  is required beyond the transport layer.

\section{IANA Considerations}

  This document makes no requests of the IANA.

  Future versions of arf MAY define frame-type registries or well-known
  package namespaces.  Such extensions MUST define their own IANA
  interactions as appropriate.

\section{References}
\printbibliography[heading=none,resetnumbers=true]

\section{Acknowledgements}

  The author thanks the contributors to early discussions on arf's design,
  particularly those who provided feedback on streaming semantics, package
  versioning, and binary framing constraints.

  The structure and terminology of this document were influenced by the
  style of the IETF and prior work on schema-based RPC systems, including
  Protocol Buffers, Cap’n Proto, and Thrift.


\section{Appendices}
\appendix

  \section{FNV-1a-32 Reference Implementation}
  \label{annex:a}

    \begin{lstlisting}[language=arfC]
#define ARF_FNV1A32_OFFSET 0x811C9DC5u
#define ARF_FNV1A32_PRIME  0x01000193u

/* Compute FNV-1a over an arbitrary byte sequence. */
uint32_t arf_fnv1a32(const uint8_t *data, size_t len) {
    uint32_t h = ARF_FNV1A32_OFFSET;

    for (size_t i = 0; i < len; i++) {
        h ^= (uint32_t)data[i];
        h *= ARF_FNV1A32_PRIME;  /* 32-bit unsigned wraparound */
    }

    return h;
}

/* Convenience helper for NUL-terminated UTF-8 strings. */
uint32_t arf_fnv1a32_cstr(const char *s) {
    const uint8_t *p = (const uint8_t *)s;
    uint32_t h = ARF_FNV1A32_OFFSET;

    while (*p) {
        h ^= (uint32_t)*p++;
        h *= ARF_FNV1A32_PRIME;
    }

    return h;
}
    \end{lstlisting}

  \section{FNV-1a-32 Test Vectors (Informative)}
  \label{annex:b}

      This annex provides test vectors for the 32-bit FNV-1a hash function
      used by arf.  All strings are encoded as UTF-8 without a terminating
      NUL byte unless otherwise noted.

      \begin{center}
        \begin{tabular}{@{}ll@{}}
            \toprule
            Input string                & FNV-1a-32 output \\ \midrule
            (empty string)              & \texttt{0x811C9DC5} \\
            \texttt{"a"}                & \texttt{0xE40C292C} \\
            \texttt{"b"}                & \texttt{0xE70C2DE5} \\
            \texttt{"foobar"}           & \texttt{0xBF9CF968} \\
            \texttt{"pkg:v1beta1.common"} &
              \texttt{0xF746E480} \\
            \texttt{"svc:v1beta1.common.TimestampService"} &
              \texttt{0xEAA88025} \\
            \texttt{"method:v1beta1.common.TimestampService.GetTimestamp"} &
              \texttt{0x01015F42} \\
            \bottomrule
        \end{tabular}
      \end{center}

      Implementations SHOULD verify their FNV-1a-32 implementation against
      these test vectors before using it to derive \texttt{PackageID},
      \texttt{ServiceID}, or \texttt{MethodID} values.

  \section{C Reference Implementation for ZigZag Encoding}
  \label{annex:zigzag}

    The following C code implements ZigZag transformation for 32-bit and 64-bit
    signed integers.

    \begin{lstlisting}[language=arfC]
/* Encode signed 32-bit integer into ZigZag form. */
static inline uint32_t arf_zigzag32_encode(int32_t n) {
    return (uint32_t)(((uint32_t)n << 1) ^ (uint32_t)(n >> 31));
}

/* Decode ZigZag-encoded 32-bit integer. */
static inline int32_t arf_zigzag32_decode(uint32_t z) {
    return (int32_t)((z >> 1) ^ (uint32_t)-(int32_t)(z & 1u));
}

/* Encode signed 64-bit integer into ZigZag form. */
static inline uint64_t arf_zigzag64_encode(int64_t n) {
    return (uint64_t)(((uint64_t)n << 1) ^ (uint64_t)(n >> 63));
}

/* Decode ZigZag-encoded 64-bit integer. */
static inline int64_t arf_zigzag64_decode(uint64_t z) {
    return (int64_t)((z >> 1) ^ (uint64_t)-(int64_t)(z & 1u));
}
    \end{lstlisting}

  \section{Test Vectors for Signed Integer Encoding}
  \label{annex:testvectors}

    The following test vectors are normative.  Implementations \emph{MUST}
    produce exactly the given ZigZag and VarUInt results.

    \subsection{Common Values}

      \begin{center}
        \begin{tabular}{rrrr}
          \toprule
          Value & ZigZag($n$) & Decimal & VarUInt Encoding \\ \midrule
          0     & 0x00        & 0       & \texttt{00} \\
          -1    & 0x01        & 1       & \texttt{01} \\
          1     & 0x02        & 2       & \texttt{02} \\
          -2    & 0x03        & 3       & \texttt{03} \\
          2     & 0x04        & 4       & \texttt{04} \\
          63    & 0x7E        & 126     & \texttt{7E} \\
          -64   & 0x7F        & 127     & \texttt{7F} \\
          64    & 0x80        & 128     & \texttt{80 01} \\
          -65   & 0x81        & 129     & \texttt{81 01} \\
          300   & 0x0258      & 600     & \texttt{D8 04} \\
          -300  & 0x0257      & 599     & \texttt{D7 04} \\
          \bottomrule
        \end{tabular}
      \end{center}

    \subsection{Boundary Values}

      \subsubsection{int8}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            -128  & 0xFF        & \texttt{FF 01} \\
            127   & 0xFE        & \texttt{FE 01} \\
            \bottomrule
          \end{tabular}
        \end{center}

      \subsubsection{int16}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            -32768 & 0xFFFF     & \texttt{FF FF 03} \\
            32767  & 0xFFFE     & \texttt{FE FF 03} \\
            \bottomrule
          \end{tabular}
        \end{center}

      \subsubsection{int32}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            -2147483648 & 0xFFFFFFFF & \texttt{FF FF FF FF 0F} \\
            2147483647  & 0xFFFFFFFE & \texttt{FE FF FF FF 0F} \\
            \bottomrule
          \end{tabular}
        \end{center}

      \subsubsection{int64}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            INT64\_MIN & 0xFFFFFFFFFFFFFFFF & \texttt{FF FF FF FF FF FF FF FF FF 01} \\
            INT64\_MAX & 0xFFFFFFFFFFFFFFFE & \texttt{FE FF FF FF FF FF FF FF FF 01} \\
            \bottomrule
          \end{tabular}
        \end{center}

  \section{Implementation Notes (Informative)}
  \label{annex:impl-notes}

    This appendix provides non-normative guidance for implementers of arf
    encoders, decoders, and RPC runtimes.  The recommendations in this section
    are intended to improve robustness, interoperability, and operational
    safety, but they do not introduce additional protocol requirements beyond
    the normative text in the main body of this specification.

    \subsection{Recommended Limits}

      Although the core specification does not mandate concrete numeric limits,
      practical implementations SHOULD enforce the following upper bounds:

      \begin{itemize}
        \item \textbf{Maximum frame size}: Implementations SHOULD bound the
          size of a single arf frame (including header and payload).  A value
          on the order of 1--16~MiB is typical for RPC-style workloads, but
          deployments MAY choose tighter or looser limits based on use case.
        \item \textbf{Maximum struct body size}: Independently from the frame
          limit, implementations SHOULD bound the decoded struct body length
          (the \texttt{VarUInt(L)} prefix for a struct).  This prevents a
          malicious peer from embedding an excessively large struct within an
          otherwise reasonable frame.
        \item \textbf{Maximum nesting depth}: Decoders SHOULD enforce a maximum
          nesting depth for composite types (e.g., structs containing arrays of
          structs containing maps, and so on).  A depth limit on the order of
          32--64 is generally sufficient to prevent stack exhaustion in
          recursive decoders.
        \item \textbf{Maximum collection lengths}: Implementations SHOULD
          impose limits on:
          \begin{itemize}
            \item maximum array length,
            \item maximum map entry count,
            \item maximum string length (in bytes),
            \item maximum \texttt{bytes} length.
          \end{itemize}
          These limits SHOULD be enforced before allocating memory for the
          collection payload.
        \item \textbf{Maximum concurrent RPCs}: Servers SHOULD bound the number
          of simultaneously active \texttt{CorrelationID} values per
          connection, and MAY apply per-principal or per-IP concurrency limits
          at a higher layer.
      \end{itemize}

      Implementations SHOULD treat the violation of such local limits as a
      fatal error for the affected RPC, and MAY close the underlying
      connection if abuse is suspected.

    \subsection{VarUInt and Signed Integer Decoding}

      Implementations SHOULD adopt the following practices when decoding
      \texttt{VarUInt} and ZigZag-encoded integers:

      \begin{itemize}
        \item \textbf{Byte limit}: For 64-bit values, at most ten bytes are
          needed to represent any valid \texttt{VarUInt}.  Decoders SHOULD
          reject encodings that use more than ten bytes, even if the resulting
          numeric value would still fit in a 64-bit unsigned integer.
        \item \textbf{Early overflow detection}: When reconstructing the
          integer value, decoders SHOULD detect overflow incrementally (for
          example, before shifting or adding each new 7-bit chunk) rather than
          relying on native wraparound.
        \item \textbf{Width checking}: After applying ZigZag decoding,
          implementations MUST verify that the result falls within the range
          of the declared signed type (as specified in
          Section~\ref{sec:signed-int-encoding}).  Implementers are encouraged
          to centralize these checks in shared helpers to avoid inconsistencies
          across call sites.
      \end{itemize}

      For encoder implementations, it is RECOMMENDED to reuse the same
      \texttt{VarUInt} and ZigZag routines across all integer types to ensure
      uniform behavior and simplify testing.

    \subsection{Framing and Buffering Strategies}

      Because arf frames are carried over a reliable byte stream, endpoints
      MUST reconstruct frames from arbitrary segment boundaries.  In practice,
      many implementations adopt one of the following patterns:

      \begin{itemize}
        \item Maintain a per-connection read buffer, append bytes as they are
          received, and attempt to parse complete frames in a loop until no
          further complete frame is available.
        \item Use a small state machine that first parses the fixed header,
          then decodes \texttt{PayloadLength} using \texttt{VarUInt}, and
          finally waits until the indicated number of payload bytes are
          available before dispatching the frame.
      \end{itemize}

      Implementations SHOULD validate the \texttt{Magic} and \texttt{Version}
      fields before allocating large buffers for the payload.  If either field
      is invalid, the connection SHOULD be closed immediately.

    \subsection{Stream and RPC Lifecycle Management}

      Implementers are encouraged to model each active RPC as an explicit
      state machine keyed by \texttt{CorrelationID}.  Such a state machine
      typically tracks:

      \begin{itemize}
        \item whether \texttt{INVOKE} has been seen,
        \item whether \texttt{RESPONSE} has been sent or received,
        \item whether the input stream (if any) is open or closed,
        \item whether the output stream (if any) is open or closed,
        \item whether an \texttt{ERROR} or \texttt{CANCEL} has terminated the RPC.
      \end{itemize}

      Once the RPC completion conditions in Section~\ref{sec:rpc-completion}
      are satisfied, the corresponding state MUST be discarded and the
      \texttt{CorrelationID} returned to the pool of available identifiers.

      To avoid resource leaks, implementations SHOULD apply inactivity
      timeouts to RPCs that do not progress (for example, an input stream that
      never sends \texttt{IN\_CLOSE}, or a server that never produces
      \texttt{RESPONSE}).  Exceeding such a timeout MAY result in an
      \texttt{ERROR} frame and/or connection closure.

    \subsection{Timestamps and Clock Handling}

      arf \texttt{timestamp} values represent milliseconds since the UTC Unix
      Epoch.  The following practices are RECOMMENDED:

      \begin{itemize}
        \item Timestamps SHOULD be generated based on a monotonic, reasonably
          accurate system clock synchronized via a time protocol such as NTP
          or equivalent.
        \item When converting between local time and UTC, implementations
          SHOULD use a time-zone aware library rather than hard-coding
          offsets, in order to correctly handle daylight saving changes and
          historical time-zone adjustments.
        \item When a platform cannot represent millisecond precision, it
          SHOULD truncate fractional milliseconds toward zero when encoding,
          as described in the core specification.
      \end{itemize}

      When comparing timestamps originating from different systems,
      applications SHOULD be tolerant to moderate clock skew and SHOULD avoid
      treating small discrepancies as protocol errors.

    \subsection{Identifier Caching}

      Because FNV-1a identifier derivation is deterministic and depends only
      on fully-qualified names and fixed prefixes, implementations MAY cache
      the resulting \texttt{PackageID}, \texttt{ServiceID}, and
      \texttt{MethodID} values to avoid recomputing them at runtime.

      Typical approaches include:

      \begin{itemize}
        \item precomputing identifiers at code-generation time and emitting
          them as constants in generated stubs, or
        \item computing identifiers once at process start and storing them in
          an immutable lookup table keyed by fully-qualified name.
      \end{itemize}

      Regardless of caching strategy, compilers and build tooling MUST still
      detect collisions during schema compilation, as specified in
      Section~\ref{sec:identifiers}.

    \subsection{Error Mapping and Diagnostics}

      arf does not define a structured error payload format.  Implementations
      typically wrap \texttt{ERROR} frames with an application-specific
      structure that includes:

      \begin{itemize}
        \item a machine-readable error code,
        \item a human-readable message,
        \item optional metadata such as retry hints or correlation tokens.
      \end{itemize}

      It is RECOMMENDED that runtimes map transport- or decoding-level failures
      (such as malformed frames, invalid VarUInt encodings, or type width
      violations) to \texttt{ERROR} frames only when the connection remains
      otherwise usable.  If the integrity of the framing layer is in doubt
      (for example, due to a bad magic number or a severely malformed header),
      the implementation SHOULD close the connection instead of attempting to
      recover.
\end{document}
