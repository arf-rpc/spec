\documentclass[a4paper, 10pt]{article}
\hyphenpenalty=8000
\textwidth=125mm
\textheight=185mm

\usepackage{graphicx}
\usepackage{alltt}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{tikz}
\usepackage{fancyvrb}
\usetikzlibrary{matrix,fit}
\usepackage[hidelinks=true]{hyperref}
\usepackage{float}
\usepackage{enumitem}

\usepackage[
  backend=biber,
  style=numeric,
  citestyle=numeric,
  date=iso,
  defernumbers=true
]{biblatex}

\DeclareFieldFormat{labelnumber}{%
  \iffieldundef{shorthand}
    {#1}
    {\printfield{shorthand}}}

\addbibresource{spec.bib}

\setlength\bibitemsep{1em}

\lstdefinelanguage{arf}{
  sensitive = true,
  keywords={},
  otherkeywords={% Operators
    =, ;, (, ), {, }, ->, <, >, \,, @
  },
  keywords = [2]{
    uint8, uint16, uint32, uint64, int8, int16, int32, int64,
    float32, float64, string, bool, bytes, timestamp,
    package, import, enum, struct, service, stream,
    map, array, optional, @deprecated
  },
  keywordstyle=\color{gray},
  keywordstyle=[2]\color{blue},
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  comment=[l]{\#},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]",
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt,
  framesep=10pt
}

\lstdefinelanguage{meta-arf}{
  sensitive = true,
  keywords={},
  otherkeywords={% Operators
    <, >
  },
  keywords = [2]{},
  keywordstyle=\color{gray},
  keywordstyle=[2]\color{blue},
  numbers=none,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{purple}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]",
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt,
  framesep=10pt
}

\lstdefinelanguage{plain}{
  sensitive = true,
  keywords={},
  otherkeywords={},
  keywords = [2]{},
  numbers=none,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt,
  framesep=10pt
}

\lstdefinelanguage{arfC}{
  sensitive=true,
  morekeywords={
    auto, break, case, char, const, continue, default, do, double, else,
    enum, extern, float, for, goto, if, inline, int, long, register,
    restrict, return, short, signed, sizeof, static, struct, switch,
    typedef, union, unsigned, void, volatile, while,
    uint8_t, uint16_t, uint32_t, uint64_t,
    int8_t, int16_t, int32_t, int64_t,
    size_t
  },
  morekeywords=[2]{NULL},
  keywordstyle=\color{blue},
  keywordstyle=[2]\color{purple},
  identifierstyle=\color{black},
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{gray}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]",
  morestring=[b]',
  numbers=left,
  numberstyle=\scriptsize,
  stepnumber=1,
  numbersep=8pt,
  showstringspaces=false,
  breaklines=true,
  frame=top,
  framesep=10pt,
  basicstyle=\ttfamily\small,
  aboveskip=20pt,
  belowskip=20pt
}

\pagestyle{fancy}

\fancyhf{}
\fancyhead[L]{\small arf - Another RPC Framework}
\fancyhead[C]{}
\fancyhead[R]{\small Sartori}

\renewcommand{\headrulewidth}{0.4pt}

\newcommand{\secref}[1]{\S~\ref{#1}}

\fancypagestyle{firstpage}{%
  \fancyhf{} % clear
  \fancyhead[L]{}
  \fancyhead[R]{}
  \renewcommand{\headrulewidth}{0pt}
  \fancyfoot[C]{\thepage}
}

\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0pt} % no line above footer (optional)



\pagenumbering{arabic}
\setcounter{page}{1}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\newcommand{\doi}[1]{\href{https://doi.org/#1}{\texttt{https://doi.org/#1}}}

\setcounter{secnumdepth}{5}
\setcounter{tocdepth}{5}

\makeatletter
\newcommand\subsubsubsection{%
  \@startsection{paragraph}{4}{\z@}%
    {2.5ex \@plus 1ex \@minus .25ex}%
    {1.25ex \@plus .25ex}%
    {\normalfont\normalsize\bfseries}%
}
\newcommand\subsubsubsubsection{%
  \@startsection{subparagraph}{5}{\z@}%
    {2.5ex \@plus 1ex \@minus .25ex}%
    {1.25ex \@plus .25ex}%
    {\normalfont\normalsize\bfseries}%
}
\makeatother

\begin{document}

\renewcommand{\labelenumii}{\arabic{enumi}.\arabic{enumii}}
\renewcommand{\labelenumiii}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}}
\renewcommand{\labelenumiv}{\arabic{enumi}.\arabic{enumii}.\arabic{enumiii}.\arabic{enumiv}}

\thispagestyle{firstpage}

\begin{center}
\LARGE
\textbf{arf - Another RPC Framework}\\[6pt]
\small
\textbf {Vito Sartori, November 2025}\\[6pt]
\vskip 25mm
\end{center}

\begin{abstract}
  The Another RPC Framework (stylized \texttt{arf}) defines an interface
  description language (IDL), a compact binary serialization format, and a
  request/response protocol for service-oriented communication.

  arf aims to provide a simple, evolvable, and highly efficient system for
  defining structs, services, and RPC methods while eliminating the need for
  field numeric identifiers in IDL source files. arf emphasizes readability,
  forward compatibility, and minimal over-the-wire footprint.

\vskip 2mm

\end{abstract}

\pagebreak

\section{Status of This Memo}

  This document is an Internet-Draft and is submitted in full conformance with
  the provisions of BCP 78 and BCP 79.

  Internet-Drafts are working documents of the Internet Engineering Task Force
  (IETF).  They are draft documents valid for a maximum of six months and may be
  updated, replaced, or obsoleted at any time.

\section{Copyright Notice}

  \begin{flushleft}
  Copyright \copyright\ 2025 Vito Sartori. All rights reserved.
  \end{flushleft}

\pagebreak

\tableofcontents

\pagebreak

\section{Introduction}

  arf (Another RPC Framework) is a compact, binary, schema-first RPC mechanism
  designed for service-oriented systems. arf provides:

  \begin{itemize}
    \item A simple IDL with packages, imports, structs, and services.
    \item Efficient binary encoding without field tags on the wire.
    \item Optional types without nested “option” wrappers.
    \item Evolvability through package-level versioning.
    \item Re-openable service definitions for modular organization.
  \end{itemize}

  arf draws inspiration from Protobuf, Cap’n Proto, and Thrift while focusing
  on ergonomics and avoiding field-ID management clutter.


\section{Conventions and Terminology}

  The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT,
  RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this document are to be
  interpreted as described in \cite{RFC2119} and \cite{RFC8174} when, and only
  when, they appear in all capitals.

  \subsubsection{Terms}

    \begin{description}
      \item[Client] The endpoint that initiates an RPC by sending an
        \texttt{INVOKE} frame.

      \item[Server] The endpoint that receives an \texttt{INVOKE} frame
        and executes the corresponding method.

      \item[Endpoint] Either the client or the server participating in an
        RPC.

      \item[RPC] A single remote procedure call identified by one
        \texttt{CorrelationID} and consisting of an \texttt{INVOKE} frame
        and any subsequent frames that share that identifier.

      \item[Frame] A discrete protocol message sent over the underlying
        transport representing an invocation, stream element, or control
        signal, as defined in Section~\ref{sec:frame-format}.

      \item[CorrelationID] The identifier that associates all frames
        belonging to the same RPC on a given connection.

      \item[Active RPC] An RPC for which an \texttt{INVOKE} frame has been sent
        and for which the RPC completion conditions defined in
        Section~\ref{sec:rpc-completion} have not yet been satisfied.

      \item[Unary] A non-streaming RPC parameter or result, serialized as
        a single value rather than as a sequence.

      \item[Stream] A potentially unbounded sequence of values of a given
        type, carried using \texttt{IN\_STREAM}/\texttt{IN\_CLOSE} or
        \texttt{OUT\_STREAM}/\texttt{OUT\_CLOSE} frames.

      \item[Input stream] A stream of values flowing from client to
        server as part of an RPC.

      \item[Output stream] A stream of values flowing from server to
        client as part of an RPC.

      \item[Form] One of the sixteen method signature combinations
        defined in Section~\ref{RPC-MethodForms}, derived from the
        presence or absence of unary input, unary output, input stream,
        and output stream.

      \item[Struct] A user-defined composite type consisting of a fixed
        sequence of named fields.

      \item[Field] A named component of a struct, identified for
        serialization by its ordinal position within the struct
        declaration.

      \item[Optional field] A struct field whose type is \texttt{optional<T>},
        whose presence or absence is indicated by an explicit presence marker
        in the serialized representation (see Section~\ref{sec:optional-fields}).

      \item[Package] A named collection of type and service declarations
        that forms a versioned namespace boundary, as defined in
        Section~\ref{sec:packages}.

      \item[Service] A named collection of RPC methods defined within a
        package.

      \item[Method] A single RPC operation defined within a service,
        identified by its name and method form.

      \item[VarUInt] The variable-length unsigned integer encoding used
        for lengths and similar quantities, as defined in
        Section~\ref{sec:length-encoding}.

      \item[Unix Epoch] The time origin defined as \texttt{1970-01-01T00:00:00Z}
        in Coordinated Universal Time (UTC), from which arf timestamps measure
        elapsed milliseconds.
    \end{description}

\section{The arf Language}

  \subsection{Packages}
  \label{sec:packages}

    An arf source file MUST begin with a \texttt{package} declaration:

    \begin{figure}[htb]
      \lstinputlisting[language=arf,firstnumber=1]{package.arf}
    \end{figure}

    Package names establish namespace boundaries and versioning domains.  A
    package name uniquely identifies all types and services defined within
    the file.  Each type defined in a package is assigned a fully-qualified
    name of the form:

    \begin{lstlisting}[language=meta-arf,firstnumber=1]
<package-name> "." <type-name>
    \end{lstlisting}

    Example:

    \begin{lstlisting}[language=plain]
v1beta1.mypackage.OtherName
    \end{lstlisting}

  \subsection{Imports}

      A source file MAY include one or more \texttt{import} directives that
      logically incorporate definitions from other arf source files:

      \lstinputlisting[language=arf,firstnumber=1]{import.arf}

      Each imported file MUST contain a \texttt{package} declaration. The
      package name of the imported file determines the fully-qualified names
      of the types it defines.

      An import MAY specify an explicit local alias using the \texttt{as}
      keyword.  If no alias is provided, the compiler MUST derive an implicit
      alias from the final component of the imported package name.

      All aliases within a single source file MUST be unique.  If two imports
      would produce the same implicit alias, or if an implicit alias collides
      with an explicit alias, the compiler MUST reject the source file.

      Referenced types of the form \texttt{<alias>.<TypeName>} MUST resolve
      unambiguously to exactly one imported package.  Fully-qualified names
      MAY be used instead of aliases and MUST NOT depend on import aliasing.

  \subsection{Types}
  \label{sec:types}

    arf provides a set of builtin types that form the foundation of the
    serialization model.  These types MAY appear as struct fields and as
    components of composite types.

    Builtin primitive types (such as integers, booleans, floating-point values,
    strings, timestamps, and byte sequences) and composite types (such as
    \texttt{array<\dots>}, \texttt{map<\dots>}, and \texttt{optional<\dots>})
    MUST NOT appear directly as unary method parameters, unary method results,
    or stream element types.  Only user-defined \texttt{struct} and
    \texttt{enum} types are permitted in RPC method signatures (see
    Section~\ref{sec:methods}).

    \begin{itemize}
      \item \texttt{bool}: a boolean value.
      \item \texttt{int8}, \texttt{int16}, \texttt{int32}, \texttt{int64}:
        signed integers of the specified width.
      \item \texttt{uint8}, \texttt{uint16}, \texttt{uint32}, \texttt{uint64}:
        unsigned integers of the specified width.
      \item \texttt{float32}, \texttt{float64}: IEEE~754 binary floating-point
        values.
      \item \texttt{string}: a sequence of UTF-8 encoded Unicode scalar values.
      \item \texttt{timestamp}: represents an instant on the UTC time-line
        encoded as an unsigned integer count of milliseconds since the UTC Unix
        Epoch.
      \item \texttt{bytes}: an arbitrary sequence of octets.
      \item \texttt{array<T>}: an ordered, variable-length sequence of values of
        type \texttt{T}.
      \item \texttt{map<K, V>}: an unordered, variable-length association
        between keys of type \texttt{K} and values of type \texttt{V}.  Only the
        following map key types (for \texttt{K}) are permitted:
        \begin{itemize}
          \item any unsigned or signed integer type, and
          \item any \texttt{enum} type.
        \end{itemize}
        All other types are forbidden as map keys.
      \item \texttt{optional<T>}: a value of type \texttt{T} that MAY be present
        or absent.
    \end{itemize}

    User-defined \texttt{struct} and \texttt{enum} types MAY also be declared
    within a package.
    All types, whether builtin or user-defined, participate uniformly in the
    serialization rules described in Section~\ref{sec:serialization}.

    Enums are encoded as unsigned integer discriminants in the range
    \(\{ x \in \mathbb{Z} \mid 0 \le x \le 65535 \}\), serialized using the
    \texttt{VarUInt} scheme.  The enum declaration and encoding rules are
    defined in Section~\ref{sec:enums}.

  \subsection{Enum Declarations}
  \label{sec:enums}

    Enums define a finite set of named constants, each associated with an
    explicit unsigned integer discriminant.  Enum values are commonly used
    as symbolic constants, status codes, and protocol signals.

    An enum declaration has the following form:

    \lstinputlisting[language=arf,firstnumber=1]{enum-decl.arf}

    Each enumeration value MUST specify an explicit, non-negative integer
    discriminant using the \texttt{=} syntax.  The following rules apply:

    \begin{itemize}
      \item Discriminant values MAY be reused within the same enum.
        If multiple enumeration members share the same discriminant, they are
        semantically equivalent at the wire level and MUST be treated as
        aliases.
      \item Discriminants MUST be elements of the set \( \{ x \in \mathbb{Z} \mid 0 \le x \le 65535 \} \).
      \item Decimal and hexadecimal literals MAY be used.
      \item The compiler MUST reject out-of-range discriminants.
    \end{itemize}

    The textual ordering of enumeration values does \emph{not} affect their
    numeric representation on the wire; only the explicitly assigned
    discriminant value is serialized.

    Enum names and value identifiers are subject to the same scoping and
    naming rules as other top-level declarations within a package.

    \subsubsection{Encoding}

      Enumeration values are serialized as unsigned integers using
      \texttt{VarUInt} encoding (Section~\ref{sec:length-encoding}).  The
      encoded numeric value is the declared discriminant of the enumeration
      case.

      Decoders MUST reject any enum value whose discriminant does not match a
      known case in the enum definition.  Discriminants MUST NOT exceed 65535
      prior to \texttt{VarUInt} encoding.

    \subsubsection{Use as Map Keys}

      Enums MAY be used as keys in \texttt{map<K,V>} types.  When used as a key,
      an enum behaves identically to its underlying unsigned integer
      discriminant.

      Equality for enum keys is determined solely by numeric equality of the
      discriminant value.

    \subsubsection{Evolution Rules}

      Enum declarations MAY be extended by introducing new values with fresh
      discriminants.

      Existing discriminants MUST NOT be changed.  Removing or reassigning a
      discriminant constitutes a breaking change and MUST be performed only by
      introducing a new package version.

      Compilers MAY warn if an enum change breaks monotonicity or introduces
      large gaps, but such gaps are not semantically invalid.

  \subsection{Struct Declarations}
  \label{sec:structs}

    Structs define a sequence of fields, each consisting of a name and a
    type, in the order in which they are written:

    \lstinputlisting[language=arf,firstnumber=1]{struct-decl.arf}

    Field numbers MUST NOT appear in arf source files.  Instead, each field
    is assigned an implicit ordinal index based solely on its position in
    the declaration, beginning at zero for the first field.  Ordinal indices
    MUST remain stable within a package version, as they are referenced by
    the binary serialization rules defined in Section~\ref{sec:serialization}.

    Struct declarations MAY include nested struct definitions.  Nested structs
    are assigned fully-qualified names in the same manner as top-level structs.

  \subsection{Annotations}
  \label{sec:annotations}

    arf supports lightweight annotations that attach metadata to declarations
    without affecting on-the-wire encoding.  An annotation is written as an
    at-sign followed by an identifier, optionally with a parenthesized list of
    string arguments:

    \begin{lstlisting}[language=arf]
@deprecated
@deprecated("use NewType instead")
@foo
@foo()
@bar("a", "b")
    \end{lstlisting}

    Annotation arguments, if present, MUST be string literals.  Whitespace
    around parentheses and commas is permitted.  An empty argument list (e.g.,
    \texttt{@foo()}) and an omitted argument list (e.g., \texttt{@foo}) are
    syntactically distinct but MUST be treated equivalently by the compiler.

    Annotations MAY appear immediately before any of the following:

    \begin{itemize}
      \item top-level \texttt{struct} declarations;
      \item top-level \texttt{enum} declarations;
      \item \texttt{service} declarations;
      \item individual \texttt{service} methods;
      \item struct fields;
      \item enumeration members.
    \end{itemize}

    Multiple annotations MAY be applied to the same declaration by listing them
    on separate lines or on the same line.  Annotations MUST NOT appear in any
    other position.

    Annotations are metadata only.  All annotations are ignored by the binary
    encoding rules defined in Section~\ref{sec:serialization} unless explicitly
    stated otherwise in this specification.

    This specification reserves the annotation name \texttt{@deprecated}.  Other
    annotation names MAY be defined by implementations or tooling but MUST NOT
    alter the binary serialization or protocol semantics defined by this
    specification.

    The \texttt{@deprecated} annotation indicates that a declaration is obsolete
    and SHOULD NOT be used by new code:

    \begin{itemize}
      \item For struct fields, \texttt{@deprecated} indicates that the field
        remains part of the wire format (and retains its ordinal position) but
        SHOULD be omitted by new senders when possible.  Receivers MUST continue
        to accept such fields if they appear.
      \item For types, services, and methods, \texttt{@deprecated} indicates
        that the declaration is retained for compatibility but SHOULD NOT be
        referenced by new implementations.
    \end{itemize}

    If arguments are provided to \texttt{@deprecated}, their contents are
    implementation-defined but SHOULD be treated as human-readable diagnostic
    text (for example, a deprecation reason or replacement hint).  Compilers
    SHOULD emit equivalent deprecation annotations to any generated code,
    depending on the target language's capabilities.

    Compilers and tooling SHOULD emit warnings when referencing
    \texttt{@deprecated} declarations.  The presence or absence of
    \texttt{@deprecated} MUST NOT change the encoding of any value on the wire,
    nor affect identifier derivation.

  \subsection{Service Declarations}

    Services groups RPC methods:

    \lstinputlisting[language=arf,firstnumber=1]{service-decl.arf}

    Method overloading (multiple methods with the same name but different
    signatures) is not permitted.  Method names MUST be unique within a service.

    Each method name MUST be unique within the merged logical service definition
    formed after processing all re-opened service blocks.  Multiple declarations
    of the same method name are permitted only when their signatures are
    identical.

  \subsubsection{Re-Openable Services}

    A service MAY be declared in multiple \texttt{service} blocks within the
    same package.  Re-opening a service does not introduce independent scopes.
    All method declarations across blocks participate in a single unified
    namespace:

    \lstinputlisting[language=arf,firstnumber=1]{service-decl-reopen.arf}

    All \texttt{service} blocks with the same service name MUST be merged
    into a single logical service definition during compilation.  If a
    method name appears in more than one block, the compiler MUST determine
    whether the corresponding method signatures are identical.

    Two method declarations are considered to have \emph{identical
    signatures} if and only if all of the following hold:

    \begin{itemize}
      \item They declare the same method name.
      \item They declare the same ordered sequence of unary input parameters.
      \item They declare the same input stream type (or both omit it).
      \item They declare the same ordered sequence of unary output values.
      \item They declare the same output stream type (or both omit it).
    \end{itemize}

    If any of these conditions is violated, the signatures are divergent,
    and the compiler MUST reject the program.

    When a service is declared across multiple \texttt{service} blocks,
    all method names contribute to the same fully-qualified method namespace.
    Duplicate method names across service blocks do not constitute overloading;
    they represent re-declaration and MUST be byte-for-byte equivalent in
    signature.

  \subsubsection{Methods}
    \label{sec:methods}

    An arf method signature consists of zero or more unary input parameters,
    at most one input stream, and either zero or more unary output parameters or
    one output stream. The presence or absence of each of these components
    determines a \emph{method form}.  Four independent boolean dimensions
    are defined:

    \begin{itemize}
      \item \textbf{HasInput}: whether the method declares at least one unary
        input parameter.
      \item \textbf{HasOutput}: whether the method declares at least one unary
        output value.
      \item \textbf{HasInputStream}: whether the method declares a single input
        stream parameter.
      \item \textbf{HasOutputStream}: whether the method declares a single
        output stream.
    \end{itemize}

    The combination of these four booleans yields sixteen logical method forms,
    but method signatures that declare unary output values and an output stream
    are not valid, as such methods could yield fragile APIs, and potentially
    impact the ergonomy of generated APIs.  This makes any method whose form
    has \textbf{HasOutput} = \texttt{true} and \textbf{HasOutputStream} =
    \texttt{true} (i.e., forms NYNY, NYYY, YYNY, and YYYY) invalid, and MUST be
    rejected by compilers.

    The remaining twelve forms are considered \emph{legal method forms}.  Each
    legal form has a well-defined set of legal frame sequences, as specified in
    Section~\ref{sec:method-forms}.

    All unary parameters, unary results, and stream element types MUST be
    defined as either \texttt{struct} or \texttt{enum} types.  Primitive and
    composite types MUST NOT appear directly in RPC method signatures.  This
    limitation ensures that all data transmitted through RPC methods is carried
    by explicitly named message types, rather than anonymous primitive or
    composite types, and restates the restriction introduced in
    Section~\ref{sec:types}.

    For the purposes of on-the-wire representation, the ordered list of unary
    input parameters of a method is treated as a \emph{unary input tuple}, and
    the ordered list of unary output values as a \emph{unary output tuple}.  A
    tuple is not a first-class type in arf; it is a serialization construct that
    encodes “zero or more ordered values” as a single payload.
    The encoding of tuples is defined in Section~\ref{sec:unary-tuples}.

  \subsubsection{IDL Syntax for Streams}

    Streams are declared using the \texttt{stream} keyword in either the
    input parameter list or the output tuple.  A method MAY declare at most
    one input stream and at most one output stream.

    Methods declaring an output stream MUST NOT declare any unary output
    values.  Its output side consists solely of the output stream.  In other
    words, method signatures in which \textbf{HasOutput} and
    \textbf{HasOutputStream} are both \texttt{true} are syntactically invalid in
    arf and MUST be rejected by compilers, as defined in
    Section~\ref{sec:methods}.

    Examples:

    \begin{lstlisting}[language=arf]
NNYN(stream T);
NYNN() -> O;
YNNY(i I) -> stream U;
YNYY(i I, stream T) -> stream U;
    \end{lstlisting}

    A streaming parameter is written as \texttt{stream <Type>}.  Unary
    parameters are written as standard name--type bindings.  Streams MUST NOT
    appear more than once on either side of the signature.

  \subsection{Fully-Qualified Names}

      Every type and service defined within a package is assigned a
      fully-qualified name of the form:

      \begin{lstlisting}[language=meta-arf,firstnumber=1]
<package-name> "." <identifier>
      \end{lstlisting}

      Fully-qualified names uniquely identify declarations across all
      packages.  Two declarations with distinct fully-qualified names are
      considered distinct, even if their unqualified names are identical or
      their definitions are structurally equivalent.

      Within a source file, references to types defined in other packages
      MAY appear in either of the following forms:

      \begin{itemize}
        \item \textbf{Aliased form}: \texttt{<alias>.<TypeName>}, where
            \texttt{<alias>} is the explicit or implicit import alias
            established by an \texttt{import} directive; or
        \item \textbf{Fully-qualified form}: \texttt{<package-name>.<TypeName>}.
      \end{itemize}

      Aliased references MUST resolve unambiguously to exactly one imported
      package.  Fully-qualified references MUST NOT depend on import aliasing
      and MUST resolve solely based on the declared package name.

      Fully-qualified names MUST remain stable across all files belonging to
      the same package version.  Changing the package name of any declaration
      constitutes a breaking change and therefore requires introducing a new
      package version.

      Methods are assigned fully-qualified names of the form:

      \begin{lstlisting}[language=meta-arf]
<package-name> "." <service-name> "." <method-name>
      \end{lstlisting}

      This string is the canonical method identity used for identifier
      derivation.

\section{Serialization}
\label{sec:serialization}

  \subsection{Overview}

    arf defines a compact binary serialization format for values of all
    builtin and user-defined types.  Serialization is deterministic and does
    not depend on field names or field numbers appearing in the IDL.  Struct
    fields are serialized in declaration order using implicit ordinal
    indices as described in Section~\ref{sec:structs}.

    All application-level integer \emph{values} (such as field values and
    lengths) are encoded using the \texttt{VarUInt} scheme (and ZigZag +
    \texttt{VarUInt} for signed integers), unless explicitly stated otherwise.
    Floating-point values are encoded in IEEE~754 binary formats using
    big-endian byte order.  Variable-length entities (such as strings,
    byte sequences, arrays, and maps) are prefixed with a length encoded using
    the variable-length integer scheme described in Section~\ref{sec:length-encoding}.

    All serialized representations are self-delimiting and do not require
    out-of-band framing.  The RPC protocol defines its own framing mechanism
    for transporting serialized values.

  \subsection{Length Encoding}
  \label{sec:length-encoding}

    arf uses an unsigned variable-length integer format (referred to in this
    document as \emph{VarUInt}) for encoding lengths of variable-sized
    objects.  VarUInt uses a base-128 continuation-bit scheme:

    \begin{itemize}
      \item Each byte contributes seven bits of payload and one continuation
        bit.
      \item For all but the final byte, the most-significant bit (MSB) MUST
        be set to~1.
      \item The final byte MUST have its MSB set to~0.
    \end{itemize}

    This format allows lengths to be encoded using between one and ten
    bytes, depending on magnitude.  An implementation MUST NOT accept
    lengths that exceed the representational capacity of a 64-bit unsigned
    integer.

    Unless explicitly stated, all length-prefixed types in this section use
    \texttt{VarUInt} for length encoding.

  \subsection{Signed Integer Encoding}
  \label{sec:signed-int-encoding}

    Signed integer values (\texttt{int8}, \texttt{int16}, \texttt{int32},
    \texttt{int64}) are encoded using a two-step process:

    \begin{enumerate}
      \item The signed value is transformed into an unsigned integer using
        ZigZag encoding.
      \item The resulting unsigned integer is serialized using the
        \texttt{VarUInt} scheme defined in Section~\ref{sec:length-encoding}.
    \end{enumerate}

    \subsubsection{ZigZag Transformation}

      ZigZag encoding maps signed integers to unsigned integers such that small
      magnitude values (both positive and negative) produce small unsigned
      values when serialized.  This ensures that numerically small signed values
      compress efficiently under \texttt{VarUInt} encoding.

      For a signed integer value $n$ of bit-width $w$, the ZigZag transform is
      defined as:

\[
z = (n \ll 1) \oplus (n \gg (w - 1))
\]

      Where:
        \begin{itemize}
          \item $\ll$ denotes arithmetic left-shift,
          \item $\gg$ denotes arithmetic right-shift,
          \item $\oplus$ denotes bitwise exclusive OR, and
          \item $w$ is the width of the signed integer type in bits.
        \end{itemize}

      The inverse transformation is defined as:

\[
n = (z \gg 1) \oplus -(z \wedge 1)
\]

    \subsubsection{Width Enforcement}

      Although ZigZag and \texttt{VarUInt} operate on unbounded integers in
      theory, arf enforces strict width limits based on the declared type.

      Decoders \emph{MUST} reject any decoded value whose magnitude exceeds the
      range of the declared signed type:

      \begin{itemize}
        \item \texttt{int8}:      $-128 \le n \le 127$
        \item \texttt{int16}:     $-32{,}768 \le n \le 32{,}767$
        \item \texttt{int32}:     $-2^{31} \le n \le 2^{31}-1$
        \item \texttt{int64}:     $-2^{63} \le n \le 2^{63}-1$
      \end{itemize}

      Encoders \emph{MUST NOT} emit values outside the representable range of
      the declared type.

    \subsubsection{Rationale}

      ZigZag encoding ensures that:

      \begin{itemize}
        \item small negative integers do not expand to large encodings,
        \item signed and unsigned integers share a common storage format,
        \item the encoding is independent of machine endianness, and
        \item integer encodings remain stable across platforms and languages.
      \end{itemize}

      This scheme enables compact representation of signed integers while
      preserving fast decoding and deterministic serialization.

    \subsubsection{Worked Examples}

      The following examples illustrate ZigZag transformation and the resulting
      VarUInt encoding (32-bit width shown for clarity):

      \begin{center}
        \begin{tabular}{rrrr}
          \toprule
          Signed & ZigZag($n$) & Decimal & VarUInt Bytes \\ \midrule
          0      & 0x00        & 0       & \texttt{00}   \\
          -1     & 0x01        & 1       & \texttt{01}   \\
          1      & 0x02        & 2       & \texttt{02}   \\
          -2     & 0x03        & 3       & \texttt{03}   \\
          2      & 0x04        & 4       & \texttt{04}   \\
          300    & 0x0258      & 600     & \texttt{D8 04}\\
          -300   & 0x0257      & 599     & \texttt{D7 04}\\
          \bottomrule
        \end{tabular}
      \end{center}

      For example, for $n = -1$:

\[
z = (-1 \ll 1) \oplus (-1 \gg 31) = 1
\]

      ZigZag(-1) therefore produces \texttt{0x01}, which is encoded as a
      single-byte VarUInt.


    \subsubsection{Mapping Summary (Signed → ZigZag → VarUInt)}

      \begin{center}
        \begin{tabular}{rrr}
          \toprule
          Signed & ZigZag($n$) & VarUInt Encoding \\ \midrule
          0      & 0           & \texttt{00} \\
          -1     & 1           & \texttt{01} \\
          1      & 2           & \texttt{02} \\
          -2     & 3           & \texttt{03} \\
          2      & 4           & \texttt{04} \\
          -3     & 5           & \texttt{05} \\
          3      & 6           & \texttt{06} \\
          300    & 600         & \texttt{D8 04} \\
          -300   & 599         & \texttt{D7 04} \\
          \bottomrule
        \end{tabular}
      \end{center}

  \subsection{Primitive Types}

    The serialization of primitive types is defined as follows:

    \begin{itemize}
      \item \textbf{bool}: encoded as a single byte.  The value \texttt{0x00}
        represents \texttt{false}; the value \texttt{0x01} represents
        \texttt{true}.  No other values are permitted.
      \item \textbf{uint8}, \textbf{uint16}, \textbf{uint32}, \textbf{uint64}:
        encoded as \texttt{VarUInt} (Section~\ref{sec:length-encoding}).  The
        encoded value MUST lie within the range of the corresponding unsigned
        integer type.  Decoders MUST reject values that exceed the representable
        range of the declared type.
      \item \textbf{int8}, \textbf{int16}, \textbf{int32}, \textbf{int64}:
        encoded as a signed variable-length integer using ZigZag encoding
        wrapped in a \texttt{VarUInt}.  Let $n$ be the signed value and $z$ the
        ZigZag-transformed unsigned integer.  Encoders MUST compute $z$ and emit
        it using \texttt{VarUInt}; decoders MUST recover $n$ from $z$ and verify
        that it lies within the range of the declared signed type.
      \item \textbf{float32}, \textbf{float64}: encoded in IEEE~754 binary32
        or binary64 format respectively, using big-endian byte order.
      \item \textbf{string}: encoded as \texttt{VarUInt(length)} followed by
        \texttt{length} bytes containing UTF-8 encoded scalar values.
        Invalid UTF-8 byte sequences MUST cause deserialization to fail.
      \item \textbf{bytes}: encoded as \texttt{VarUInt(length)} followed by
        \texttt{length} raw octets.
      \item \textbf{timestamp}: encoded as \texttt{VarUInt} representing the
        number of milliseconds elapsed since the UTC Unix Epoch.
        Implementations that cannot represent millisecond precision MUST
        truncate toward zero.
    \end{itemize}

    These encodings are used uniformly whether a primitive appears as a
    struct field or within a composite type.  However, primitives MUST NOT be
    used as unary method parameters, unary method results, or as stream
    elements.  For methods, unary inputs, unary outputs, and streams MUST use
    structs or enums as specified in Section~\ref{sec:methods}.

    Key equality is defined by equality of the underlying key value.
    For integer keys, numeric equality applies.  For enumeration keys,
    equality is determined by numeric equality of their discriminants.

    Because structured types are forbidden as keys, equality testing is
    deterministic and independent of implementation-specific behavior.

  \subsection{Composite Types}

    Composite types define container-like structures with their own encoding
    rules.

    \subsubsection{Arrays}

      An \texttt{array<T>} value is encoded as:

      \begin{enumerate}
        \item \texttt{VarUInt(n)}, where $n$ is the number of elements.
        \item The concatenation of the serialized representations of the $n$
          elements in order.
      \end{enumerate}

      An array MAY be empty.  Empty arrays are encoded as \texttt{VarUInt(0)}
      followed by zero bytes.

    \subsubsection{Maps}

      A \texttt{map<K, V>} value is encoded as:

      \begin{enumerate}
        \item \texttt{VarUInt(n)}, where $n$ is the number of key--value pairs.
        \item For each pair, the serialized key immediately followed by the
          serialized value.
      \end{enumerate}

      A map MAY be empty.  Map iteration order MUST be the order chosen by the
      encoder and MUST be preserved by the decoder without implying semantic
      ordering or sorting.

      Keys MUST be unique according to the equality semantics of type
      \texttt{K}.  Encoders MUST NOT emit duplicate keys and deserializers
      MUST reject maps that contain duplicate keys.

    \subsubsection{Structs}

      Struct values are serialized as \emph{length-prefixed records}.  Each
      struct instance is preceded by a byte length that defines the total
      size of the struct body in bytes, allowing decoders to skip unknown
      types safely.

      A struct value is encoded as:

      \begin{enumerate}
        \item \texttt{VarUInt(L)}, where $L$ is the number of bytes in the
          struct body that follows; and
        \item the struct body, consisting of the serialized field values in
          declaration order.
      \end{enumerate}

      No field numbers or tag identifiers appear on the wire; fields are
      identified solely by their ordinal position within the struct.

      Let a struct contain $m$ fields.  The struct body is encoded as the
      concatenation, in declaration order, of the encodings for each field:

      \begin{enumerate}
        \item For a field whose declared type is \texttt{optional<T>}:
          \begin{itemize}
            \item Emit a single \emph{presence byte}.
              The value \texttt{0x00} denotes ``absent'' and the value
              \texttt{0x01} denotes ``present''.  No other values are
              permitted.
            \item If the presence byte is \texttt{0x01}, emit the serialized
              representation of \texttt{T}, encoded according to the
              rules for type \texttt{T}.
            \item If the presence byte is \texttt{0x00}, no additional bytes
              are emitted for that field.
          \end{itemize}

        \item For a field whose declared type is not \texttt{optional<\dots>}:
          emit the serialized representation of the field value according to
          the rules for its type.  Encoders \emph{MUST NOT} omit fields;
          decoders \emph{MUST} treat truncation before the end of a required
          field as an error.
      \end{enumerate}

      Decoders \emph{MUST} NOT assume knowledge of the physical layout of a
      struct beyond the fields they explicitly recognize.  After decoding the
      fields they understand, implementations \emph{MUST} skip any remaining
      trailing bytes in the struct body as determined by the length prefix.

      Because field ordinals define the on-wire layout, implementations
      \emph{MUST NOT} reorder fields within a package version.

  \subsection{Unary Tuples}
  \label{sec:unary-tuples}

    Unary tuples are serialization-only aggregates used to carry the ordered
    list of unary input parameters or unary output values of a method as a
    single payload.  Tuples are not declared in arf sources; they are derived
    mechanically from the method signature.

    Let a unary tuple contain $n$ values $v_0, v_1, \dots, v_{n-1}$, each
    with a declared type $T_i$ (where each $T_i$ is a \texttt{struct} or
    \texttt{enum}, as required by Section~\ref{sec:methods}).  The tuple is
    encoded as:

    \begin{enumerate}
      \item \texttt{VarUInt(L)}, where $L$ is the total number of bytes
        occupied by the concatenation of the serialized values $v_i$; and
      \item the serialized representations of $v_0, v_1, \dots, v_{n-1}$ in
        declaration order, each encoded according to the rules for its type.
    \end{enumerate}

    Thus, the on-wire layout of a tuple is:

\[
\text{VarUInt}(L) \;\|\; \text{encode}(v_0) \;\|\; \text{encode}(v_1) \;\|\; \dots \;\|\; \text{encode}(v_{n-1})
\]

    A tuple MAY be empty ($n = 0$).  An empty tuple is encoded as
    \texttt{VarUInt(0)} followed by zero bytes.

    Because each tuple is length-delimited by its leading \texttt{VarUInt(L)},
    decoders can skip unknown trailing values if a method signature is
    extended by appending unary inputs or unary outputs in a later method
    version, provided both sides agree on the method form and framing
    semantics.

  \subsection{Optional Fields}
  \label{sec:optional-fields}

    An \texttt{optional<T>} value MAY be present or absent.  The encoding of
    \texttt{optional<T>} is uniform regardless of where it appears (struct
    field, array element, map value, or nested inside other composite types).

    An \texttt{optional<T>} value is encoded as:

    \begin{itemize}
      \item a single presence byte, where \texttt{0x00} denotes ``absent''
        and \texttt{0x01} denotes ``present''; and
      \item if the presence byte is \texttt{0x01}, the serialized representation
        of \texttt{T}, encoded according to the rules for type \texttt{T}.
    \end{itemize}

    If the presence byte is \texttt{0x00}, no additional bytes are emitted
    for that value.

    The type parameter \texttt{T} MUST be a valid arf type, including
    primitive types, composite types (such as \texttt{array<\dots>} and
    \texttt{map<\dots>}), structs, enums, or even another \texttt{optional<U>}.

    When \texttt{optional<T>} is used as a struct field type, its encoding
    follows the same rules as above and contributes to the struct body in
    declaration order.

  \subsection{Error Handling}

    A deserializer MUST reject any of the following:

    \begin{itemize}
      \item malformed VarUInt encodings,
      \item lengths that exceed the remaining buffer,
      \item invalid UTF-8 in \texttt{string} values,
      \item duplicate keys in a \texttt{map<K,V>},
      \item trailing bytes beyond a declared length prefix for any
        length-delimited value,
      \item any violation of the structural constraints defined in
        this section.
    \end{itemize}

    Unless explicitly specified, deserialization errors MUST be treated as
    fatal to the enclosing RPC invocation.

  \subsection{Binary Layout Example}
  \label{sec:layout-example}

    This section provides a concrete example illustrating how arf encodes
    structs and how length-prefixing enables safe evolution.

    Consider the following initial struct definition:

    \begin{lstlisting}[language=arf]
struct User {
    id   uint32;
    name string;
}
    \end{lstlisting}

    This struct contains two fields.  A serialized instance is encoded as:

    \begin{center}
      \begin{tabular}{ll}
        \toprule
        Component   & Description \\
        \midrule
        VarUInt(L)      & Length of the struct body in bytes \\
        Field 0         & \texttt{id} (uint32) \\
        Field 1 length  & VarUInt indicating the length of Field 1 \\
        Field 1 value   & \texttt{name} (string) \\
        \bottomrule
      \end{tabular}
    \end{center}

    Assume an evolution where a new optional field is appended:

    \begin{lstlisting}[language=arf]
struct User {
    id    uint32;
    name  string;
    email optional<string>;
}
    \end{lstlisting}

    The new binary layout becomes:

    \begin{center}
      \begin{tabular}{ll}
        \toprule
        Component      & Description \\
        \midrule
        VarUInt(L')    & New struct body length \\
        Field 0        & \texttt{id} (uint32) \\
        Field 1 length & VarUInt indicating the length of Field 1 \\
        Field 1 value  & \texttt{name} (string) \\
        Field 2 tag    & Presence byte for \texttt{email} (\texttt{0x00} or \texttt{0x01}) \\
        Field 2 value  & \texttt{string} payload if present (\texttt{email}) \\
        \bottomrule
      \end{tabular}
    \end{center}

    When an older receiver (that only knows the two-field layout) decodes this
    value, it proceeds as follows:

    \begin{itemize}
      \item It reads \texttt{VarUInt(L')} and learns the total size of the
        struct body.
      \item It decodes only the fields it recognizes (the first two).
      \item It treats the remaining bytes in the struct body as unknown data and
        skips them using the length prefix.
    \end{itemize}

    Because all struct values are length-delimited, receivers never need to
    understand the internal layout of unknown fields in order to skip them
    safely.  This guarantees forward compatibility for nested structs, arrays of
    structs, and arbitrarily complex type graphs.

\section{RPC Protocol}
\label{sec:rpc-protocol}

  arf defines a bidirectional message-oriented protocol used to transport
  serialized request and response values between a client and a server.
  This section defines the framing model, identifier space, message
  semantics, and the legal frame sequences for each method form defined in
  Section~\ref{sec:method-forms}.

  Unless otherwise noted, all multi-byte integer fields are encoded in
  big-endian byte order.  All frames are self-contained and do not rely
  on lower-layer segmentation semantics.

  \subsection{Frame Format}
  \label{sec:frame-format}

    Each message exchanged between a client and server is encoded as an arf
    \emph{frame}.  Frames are logical protocol units: bytes belonging to two
    different frames MUST NOT be interleaved on the wire.  A single frame MAY
    be split across multiple transport segments, but the concatenation of
    bytes delivered by the transport for that connection MUST form a
    well-defined sequence of complete frames.  The format of a frame is:

    \begin{center}
      \begin{tabular}{@{}ll@{}}
        \toprule
        Field               & Description \\
        \midrule
        Magic[2]            & Fixed value \texttt{0xAF 0x01} identifying arf framing. \\
        Version[1]          & Protocol version.  This document specifies version~1. \\
        MessageKind[1]      & Indicates the semantic type of the frame. \\
        Flags[1]            & Reserved for future use; MUST be zero for version~1. \\
        CorrelationID[8]    & Opaque identifier linking frames belonging to the same RPC. \\
        PayloadLength (var) & Length of the payload using VarUInt encoding. \\
        Payload (var)       & Frame payload.  Payload layout is defined in the frame-type subsections below. \\
        \bottomrule
      \end{tabular}
    \end{center}

    All frames MUST begin with the 2-byte magic value.  Receivers MUST treat a
    mismatched magic value as a framing error and close the connection.

    \subsubsection{MessageKind}
    \label{sec:messagekind}

      The \texttt{MessageKind} byte MUST be one of the following:

      \begin{center}
        \begin{tabular}{@{}ll@{}}
          \toprule
            Value & Meaning \\ \midrule
            0x01  & \texttt{INVOKE}: initiates an RPC call. \\
            0x02  & \texttt{CONTINUE}: server acknowledgment of \texttt{INVOKE}. \\
            0x03  & \texttt{IN\_STREAM}: element of an input stream. \\
            0x04  & \texttt{IN\_CLOSE}: signals end of input stream. \\
            0x05  & \texttt{OUT\_STREAM}: element of an output stream. \\
            0x06  & \texttt{OUT\_CLOSE}: signals end of output stream. \\
            0x07  & \texttt{RESPONSE}: unary output payload and RPC termination. \\
            0x08  & \texttt{ERROR}: terminal error (Section~\ref{sec:error-frames}). \\
            0x09  & \texttt{CANCEL}: client cancellation of the RPC. \\
            0x0A  & \texttt{CANCELLED}: cancellation acknowledgement (Section~\ref{sec:cancellation}) \\
          \bottomrule
        \end{tabular}
      \end{center}

      The semantics and payloads of each frame kind are defined in
      Section~\ref{sec:requests} and subsequent subsections.  In particular:

      \begin{itemize}
        \item \texttt{CANCEL} frames MUST have a payload length of zero.  The
          \texttt{PayloadLength} field MUST encode the value~0 using
          \texttt{VarUInt}, and no payload bytes MUST follow.  Receivers MUST
          treat any \texttt{CANCEL} frame with a non-zero payload length as a
          protocol error.
      \end{itemize}

    \subsubsection{INVOKE frame}

      \texttt{INVOKE} frames serve to indicate the intention of a client to
      start an RPC call.  It carries the Package, Service and Method
      identifiers, and when \textbf{HasInput} is \texttt{true}, the unary input
      tuple required by the method.  When \textbf{HasInput} is \texttt{false},
      the \texttt{INVOKE} frame must omit the input tuple by including a single
      \texttt{VarUInt(0)} value.

      Clients MAY assume the method has begun processing after a
      \texttt{CONTINUE} frame is received in response to the \texttt{INVOKE}
      frame.  Otherwise, servers MUST return an \texttt{ERROR} frame indicating
      that the RPC binding failed and no action was taken.

      The \texttt{INVOKE} frame is composed of the following items, in order:

      \begin{itemize}
        \item \texttt{PackageID}: the identifier of the package where the RPC
          method resides encoded as an unsigned 32-bit integer.
        \item \texttt{ServiceID}: the identifier of the service providing the
          RPC method encoded as an unsigned 32-bit integer.
        \item \texttt{MethodID}: the identifier of the method being called on
          the provided package and service encoded as an unsigned 32-bit
          integer.
        \item \texttt{Payload}: when \textbf{HasInput} is \texttt{true}, the
          unary input tuple containing all inputs required by the RPC method,
          as described in Section~\ref{sec:unary-tuples}; when \textbf{HasInput}
          is \texttt{false}, no tuple is encoded and the input tuple must be
          omitted by including a single \texttt{VarUInt(0)} value, while other
          fields MUST be present.
      \end{itemize}

    \subsubsection{CONTINUE Frame}

      The \texttt{CONTINUE} frame acknowledges that the server has successfully
      validated the \texttt{INVOKE} frame and that the RPC has been bound to the
      specified \texttt{PackageID}, \texttt{ServiceID}, and \texttt{MethodID}.
      After sending \texttt{CONTINUE}, the server commits to executing the RPC
      unless a subsequent \texttt{CANCEL} frame terminates it.

      A server MUST send exactly one \texttt{CONTINUE} frame for each valid
      \texttt{INVOKE} it accepts.  If the \texttt{INVOKE} cannot be bound
      (unknown package, service, or method), the server MUST send an
      \texttt{ERROR} frame instead of \texttt{CONTINUE}.

      The payload of a \texttt{CONTINUE} frame MUST be empty.

    \subsubsection{IN\_STREAM Frame}

      The \texttt{IN\_STREAM} frame carries a value belonging to the input stream
      of a streaming-input RPC (methods for which \textbf{HasInputStream} is
      \texttt{true}).  Clients MAY send zero or more \texttt{IN\_STREAM} frames
      after receiving \texttt{CONTINUE}, as long as the method definition allows
      so.

      The payload of an \texttt{IN\_STREAM} frame consists of:

      \begin{itemize}
        \item A serialized stream element value, encoded using the type declared
          in the method signature.
      \end{itemize}

      Clients MUST NOT send \texttt{IN\_STREAM} frames after sending
      \texttt{IN\_CLOSE}, nor after sending \texttt{CANCEL}.

      Sending \texttt{IN\_STREAM} for a method that does not declare an input
      stream is a protocol error.

    \subsubsection{IN\_CLOSE Frame}

      The \texttt{IN\_CLOSE} frame signifies that the client has finished sending
      all elements of the input stream.

      If \textbf{HasInputStream} is \texttt{true}, the client MUST send exactly
      one \texttt{IN\_CLOSE} frame unless it cancels the RPC before normal
      completion.  A \texttt{IN\_CLOSE} frame MUST contain an empty payload.

      Sending \texttt{IN\_CLOSE} for a method that does not declare an input
      stream is a protocol error.

    \subsubsection{OUT\_STREAM Frame}

      The \texttt{OUT\_STREAM} frame carries a value belonging to the output
      stream of the RPC (methods for which \textbf{HasOutputStream} is
      \texttt{true}).  Servers MAY send zero or more \texttt{OUT\_STREAM} frames
      after sending \texttt{CONTINUE} and before sending \texttt{OUT\_CLOSE}.

      The payload of an \texttt{OUT\_STREAM} frame consists of:

      \begin{itemize}
        \item A serialized stream element value, encoded with the declared
          output stream type.
      \end{itemize}

      Servers MUST NOT send \texttt{OUT\_STREAM} frames after sending
      \texttt{OUT\_CLOSE}, \texttt{CANCELLED}, or \texttt{ERROR}.

      Sending \texttt{OUT\_STREAM} for a method that does not declare an output
      stream is a protocol error.

    \subsubsection{OUT\_CLOSE Frame}

      The \texttt{OUT\_CLOSE} frame signifies that the server has sent all
      output stream elements.

      A \texttt{OUT\_CLOSE} frame MUST contain an empty payload and MUST be sent
      only once during the lifecycle of the RPC.

      Sending \texttt{OUT\_CLOSE} for a method that does not declare an output
      stream is a protocol error.

      Servers MUST NOT send \texttt{OUT\_CLOSE} frames after sending
      \texttt{CANCELLED}, or \texttt{ERROR}.

    \subsubsection{CANCEL Frame}
    \label{sec:cancel-frame}

      The \texttt{CANCEL} frame is sent by the client to request early
      termination of an RPC.

      A \texttt{CANCEL} frame has an empty payload.

      Upon receiving \texttt{CANCEL} for an active RPC, the server:

      \begin{itemize}
        \item MUST notify the executor that the request has been cancelled.
        \item MUST send a single \texttt{CANCELLED} frame in response to the
          request.
        \item MUST NOT send any other frame after the \texttt{CANCELLED} frame.
        \item MUST consider any open stream as closed.
        \item MUST cause any attempt of sending a \texttt{RESPONSE},
          \texttt{OUT\_STREAM} to yield an error indicating that the RPC was
          cancelled.
        \item MUST cause any attempt of receiving a value through any available
          input stream to yield an error indicating that the RPC was cancelled.
      \end{itemize}

      RPCs MUST be aware of cancellation semantics, and must provide
      cancellation points to be able to correctly handle cancellation requests.
      Rollbacks, checkpoints, and other semantics related to cancellation are
      application-dependent and thus out of scope of this document.

      A late \texttt{CANCEL} (one received after the server considers the RPC
      complete) MUST be ignored and MUST NOT trigger any additional frame.

    \subsubsection{CANCELLED Frame}

      The \texttt{CANCELLED} frame acknowledges receipt and processing of a
      client-issued \texttt{CANCEL} for a given \texttt{CorrelationID}.  Its
      payload is empty; the \texttt{PayloadLength} field MUST be zero.

      Upon sending \texttt{CANCELLED}, the server indicates that the RPC has
      been aborted at the client's request.  A \texttt{CANCELLED} frame is a
      terminal, non-error outcome for that RPC: it terminates the RPC
      identified by its \texttt{CorrelationID} but does not imply that a fault
      occurred on the server.  Other RPCs multiplexed on the same connection are
      unaffected.

      An RPC terminated with a \texttt{CANCELLED} frame has all input and output
      streams, if any, implicitly closed.  Servers MUST ensure that any internal
      buffer or queue is drained.

    \subsubsection{ERROR Frame}

      The \texttt{ERROR} frame is the terminal negative outcome of an RPC.

      The payload of an \texttt{ERROR} frame MUST be an \emph{error payload}
      structured as:

      \begin{itemize}
        \item A structured error body containing:
          \begin{itemize}
            \item a machine-readable error code, and
            \item a human-readable message string.
            \item an optional arbitrary byte array containing extra diagnostic
              information provided by the application, if any applies.  This
              field MUST not be interpreted by servers or libraries; the value
              is intended to only be relevant to the server and client
              implementations provided by the end-user.
        \end{itemize}
      \end{itemize}

      An \texttt{ERROR} frame concludes the RPC for both endpoints. No further
      frames for the associated \texttt{CorrelationID} may be sent afterward.

  \subsection{Requests}
  \label{sec:requests}

    An RPC request is initiated by the client sending an \texttt{INVOKE} frame.
    The on-wire layout of \texttt{INVOKE} (identifiers, and unary inputs, if
    any) is defined in Section~\ref{sec:frame-format} and its frame subsections.
    This subsection specifies only sequencing and lifecycle rules.

    \begin{itemize}
      \item For each \texttt{CorrelationID}, the client sends exactly one
        \texttt{INVOKE} as the first frame. The server responds with either
        \texttt{CONTINUE} (binding succeeded) or a terminal \texttt{ERROR}
        (binding failed).
      \item If \textbf{HasInputStream} is \texttt{true}, the input stream is
        considered open after \texttt{CONTINUE}.  The client MAY send zero or
        more \texttt{IN\_STREAM} frames.  For a successfully completing RPC (no
        \texttt{CANCEL} or \texttt{ERROR}), the client MUST send exactly one
        \texttt{IN\_CLOSE}, and the server MUST NOT send \texttt{RESPONSE} until
        it has received such \texttt{IN\_CLOSE}.  After \texttt{CANCEL}, the
        client MUST NOT send any further \texttt{IN\_STREAM} or
        \texttt{IN\_CLOSE} frames for that \texttt{CorrelationID}.
      \item If \textbf{HasOutputStream} is \texttt{true}, the output stream is
        considered open after \texttt{CONTINUE}.  The server MAY send zero or
        more \texttt{OUT\_STREAM} frames.  For a successfully completing RPC (no
        \texttt{CANCEL} or \texttt{ERROR}), the server MUST send exactly one
        \texttt{OUT\_CLOSE}, and the server MUST NOT send \texttt{RESPONSE}
        until it has sent such \texttt{OUT\_CLOSE}.  After \texttt{CANCELLED},
        the server MUST NOT send any further \texttt{OUT\_STREAM} or
        \texttt{OUT\_CLOSE} frames for that \texttt{CorrelationID}.
      \item A client MUST NOT send another \texttt{INVOKE} with the same
        \texttt{CorrelationID}.  Doing so is a protocol error.  If the server
        receives a duplicate \texttt{INVOKE} for an active RPC, it MUST treat
        this as a connection-level protocol error and MUST close the transport
        without attempting to report it via \texttt{ERROR}.
    \end{itemize}

  \subsection{Transport Assumptions}
  \label{sec:transport-assumptions}

    arf is designed to run over a reliable, ordered, bidirectional transport.
    The transport MUST preserve byte order and MUST NOT duplicate or reorder
    bytes.  Examples of suitable transports include TCP connections, QUIC
    streams, and Unix domain sockets.

    Frames, as defined in Section~\ref{sec:frame-format}, are logical protocol
    units and do not necessarily align with transport-level segmentation.
    Implementations MUST tolerate arbitrary segmentation of frames by the
    underlying transport and MUST reconstruct complete frames from the incoming
    byte stream.  Bytes belonging to different frames MUST NOT be interleaved on
    the wire (see Section~\ref{sec:frame-format}).

    Datagram-oriented transports (such as bare UDP) do not satisfy these
    requirements without additional reliability and ordering mechanisms.  Such
    mechanisms are out of scope for this specification.

  \subsection{Connection Model and Multiplexing}
  \label{sec:multiplexing}

    arf is designed to support multiplexing of multiple RPCs over a single
    transport connection.  A connection is viewed as a bidirectional stream of
    frames as defined in Section~\ref{sec:frame-format}.

    \subsubsection{Correlation Identifiers}

      The \texttt{CorrelationID} field in each frame identifies the logical RPC
      to which the frame belongs.  The following rules apply:

      \begin{itemize}
        \item For a given connection, the client MUST choose a
          \texttt{CorrelationID} that is not currently active when initiating a
          new  RPC.
        \item An RPC becomes active when its \texttt{INVOKE} frame is sent.  It
          remains active until the RPC completion conditions defined in
          Section~\ref{sec:rpc-completion} are satisfied.
        \item Once an RPC has completed, its \texttt{CorrelationID} MAY be
          reused for a subsequent RPC on the same connection.
      \end{itemize}

      Implementations MUST treat the receipt of frames for an unknown or
      inactive \texttt{CorrelationID} as a protocol error, \emph{except} for
      \texttt{CANCEL} frames.  A \texttt{CorrelationID} is considered inactive
      if and only if the completion conditions in
      Section~\ref{sec:rpc-completion} have been satisfied for that identifier.

      A \texttt{CANCEL} frame received for an unknown or inactive
      \texttt{CorrelationID} (as defined in Section~\ref{sec:rpc-completion})
      MUST be silently ignored and MUST NOT be treated as a protocol violation.

    \subsubsection{Concurrent RPCs}

      Clients MAY initiate multiple RPCs concurrently over the same connection
      by sending multiple \texttt{INVOKE} frames with distinct
      \texttt{CorrelationID} values.  Similarly, servers MAY process multiple
      RPCs concurrently and interleave frames for those RPCs arbitrarily.

      For each individual \texttt{CorrelationID}, the following invariants MUST
      hold:

      \begin{itemize}
        \item Exactly one \texttt{INVOKE} frame MUST appear, and it MUST be the
          first frame for that \texttt{CorrelationID}.  A second \texttt{INVOKE}
          for an active \texttt{CorrelationID} is a connection-level protocol
          error (see Section~\ref{sec:requests} and
          Section~\ref{sec:error-frames}).
        \item All subsequent frames with that \texttt{CorrelationID} MUST
          conform to the method form and sequencing rules defined in
          Section~\ref{sec:method-forms}.

        \item Once the RPC completion conditions defined in
          Section~\ref{sec:rpc-completion} have been satisfied,
          endpoints MUST treat the \texttt{CorrelationID} as inactive and MUST
          NOT send further frames for that \texttt{CorrelationID}.
      \end{itemize}

      Frames belonging to different \texttt{CorrelationID} values MAY be
      arbitrarily interleaved in both directions, subject to any flow-control or
      prioritization policies implemented by the endpoints.

    \subsubsection{Ordering Guarantees}

      The transport MUST preserve byte order, and endpoints MUST preserve the
      frame order in which data is received.  As a consequence:

      \begin{itemize}
        \item For a given \texttt{CorrelationID}, the sequence of frames is
          strictly ordered and can be processed in order.
        \item No ordering guarantees are provided between frames belonging to
          different \texttt{CorrelationID} values beyond those implied by
          the underlying transport.
      \end{itemize}

      arf does not define fairness or prioritization between concurrent RPCs.
      Such policies are implementation-specific and MAY be influenced by
      application-level considerations.

  \subsection{Identifiers}
  \label{sec:identifiers}

    PackageID, ServiceID, and MethodID are 32-bit unsigned integers derived
    from the fully-qualified names of packages, services, and methods using
    the FNV-1a hash function.  The hash function MUST be implemented exactly
    as specified in this section; all conforming implementations MUST produce
    identical identifiers for the same fully-qualified name.

    The identifier derivation scheme is intentionally opaque in arf source
    files and MUST NOT be user-configurable.  Identifiers MUST remain
    stable for the lifetime of a package version.  Changing any identifier
    constitutes a breaking change requiring a new package version.

    \subsubsection{FNV-1a Hash Function}

      arf derives \texttt{PackageID}, \texttt{ServiceID}, and \texttt{MethodID}
      values using the FNV-1a non-cryptographic hash function operating on
      32-bit unsigned integers.  FNV-1a is selected for its simplicity,
      determinism, efficiency, and well-defined behavior across implementations.

      The FNV-1a algorithm MUST be implemented exactly as specified in this
      section.  All conforming implementations MUST produce identical hash
      outputs for the same input byte sequence.

      The hash function operates over a sequence of octets and produces a single
      32-bit unsigned integer.  Arithmetic is performed using unsigned 32-bit
      modular arithmetic with wraparound on overflow.

      FNV-1a is not a cryptographic hash function and MUST NOT be used for
      security-sensitive purposes such as message authentication, integrity
      verification, or identity proof.  Its sole purpose in arf is deterministic
      identifier derivation.

      The domain of the input to the hash function is restricted and
      well-defined.  Implementations MUST apply namespace-specific prefixes
      prior to hashing to ensure that identifiers for different kinds of
      entities do not collide.  The input to the hash function for each
      identifier is defined as follows:

      \begin{itemize}
        \item \textbf{PackageID} is derived from:
          \texttt{"pkg:" || <package-fqn>}
        \item \textbf{ServiceID} is derived from:
          \texttt{"svc:" || <service-fqn>}
        \item \textbf{MethodID} is derived from:
          \texttt{"method:" || <package> "." <service> "." <method>}
      \end{itemize}

      The fully-qualified name strings MUST be encoded as UTF-8 prior to
      hashing, without terminating null bytes or additional normalization.

      Collisions MUST be detected at compile time.  If two distinct
      fully-qualified names produce the same identifier within the same
      identifier space (package, service, or method), the compiler MUST reject
      the program.  Implementations MUST NOT accept such collisions silently.

      Implementations MUST treat the input byte stream as an ordered sequence of
      octets.  No Unicode normalization, case-folding, or locale-sensitive
      transformation is permitted.

      The normative description and reference implementation of the FNV-1a
      algorithm appear below.

      \begin{lstlisting}[language=plain]
FNV-1a-32(input):

  Let offset_basis = 2166136261 (0x811C9DC5).
  Let FNV_prime    = 16777619   (0x01000193).

  Let h = offset_basis.
  For each byte b in input, in order:
      h = h XOR b
      h = (h * FNV_prime) mod 2^32

  Return h.
      \end{lstlisting}

      A C reference implementation and test vectors are provided in
      \hyperref[annex:a]{Appendix A} and \hyperref[annex:b]{Appendix B},
      respectively.

  \subsection{Method Forms and Allowed Frame Sequences}
  \label{sec:method-forms}

    arf defines sixteen distinct \emph{method forms}, derived from the
    presence or absence of: (1) unary input parameters, (2) unary output
    values, (3) an input stream, and (4) an output stream.  The four-letter
    form label encodes the booleans \texttt{HasInput}, \texttt{HasOutput},
    \texttt{HasInputStream}, and \texttt{HasOutputStream}, respectively,
    using \texttt{Y} for ``present'' and \texttt{N} for ``absent''.

    Table~\ref{tab:method-forms} specifies, for each form, whether the
    client and server MAY send the streaming frame kinds defined in
    Section~\ref{sec:frame-format}.  Frames belonging to different
    \texttt{CorrelationID} values MAY be arbitrarily interleaved on the same
    connection, as described in Section~\ref{sec:multiplexing}.

    Frames considered as \emph{invalid} per Section~\ref{sec:methods} are not
    included in Table~\ref{tab:method-forms}.

    \begin{table}[H]
      \centering
      \caption{arf Method Forms and Permitted Streaming Frames}
      \label{tab:method-forms}
      \begin{tabular}{lcccccccc}
        \toprule
        Form &
        HasIn &
        HasOut &
        HasInS &
        HasOutS &
        C:IS &
        C:IC &
        S:OS &
        S:OC \\
        \midrule
        NNNN & N & N & N & N & N & N & N & N \\
        NNNY & N & N & N & Y & N & N & Y & Y \\
        NNYN & N & N & Y & N & Y & Y & N & N \\
        NNYY & N & N & Y & Y & Y & Y & Y & Y \\
        NYNN & N & Y & N & N & N & N & N & N \\
        NYYN & N & Y & Y & N & Y & Y & N & N \\
        YNNN & Y & N & N & N & N & N & N & N \\
        YNNY & Y & N & N & Y & N & N & Y & Y \\
        YNYN & Y & N & Y & N & Y & Y & N & N \\
        YNYY & Y & N & Y & Y & Y & Y & Y & Y \\
        YYNN & Y & Y & N & N & N & N & N & N \\
        YYYN & Y & Y & Y & N & Y & Y & N & N \\
        \bottomrule
      \end{tabular}

      \vskip 0.5em

      \raggedright
      \footnotesize
      \noindent
      \textbf{Note:} The permissions in this table apply only to RPCs that
        complete successfully.  If an RPC is terminated by \texttt{CANCEL} or
        \texttt{ERROR}, \texttt{IN\_CLOSE} and \texttt{OUT\_CLOSE} are neither
        required nor permitted.  Cancellation semantics are defined in
        Section~\ref{sec:cancellation}.

      \vskip 0.5em

      \textbf{Note:} The table indicates which frame types may appear for a
      given method form.  It does not express sequencing or success-completion
      requirements.  When a stream is present, exactly one corresponding
      \texttt{IN\_CLOSE} or \texttt{OUT\_CLOSE} frame is required for
      successful completion (see Sections~\ref{sec:requests} and
      \ref{sec:output-stream}).

      \vskip 0.5em
      \textbf{Legend}

      \begin{description}[
        style=sameline,
        leftmargin=45pt,
        labelsep=1.2em,
        labelwidth=4em,
        align=left,
        font=\normalfont\ttfamily
      ]
        \item[HasIn]  HasInput
        \item[HasOut] HasOutput
        \item[HasInS] HasInputStream
        \item[HasOutS] HasOutputStream
        \item[C:IS]   client MAY send \texttt{IN\_STREAM}
        \item[C:IC]   client MAY send \texttt{IN\_CLOSE}
        \item[S:OS]   server MAY send \texttt{OUT\_STREAM}
        \item[S:OC]   server MAY send \texttt{OUT\_CLOSE}
      \end{description}
    \end{table}

    The following rules apply only to RPCs that complete successfully.  In the
    presence of cancellation or error, the stream-termination requirements in
    this section are overridden by the cancellation and error semantics
    defined in Section~\ref{sec:error-and-cancel}.

    For each form, the following additional constraints apply, per
    \texttt{CorrelationID}:

    \begin{itemize}
      \item The generic request invariants from Section~\ref{sec:requests}
        apply unchanged: for each \texttt{CorrelationID}, the client sends
        exactly one \texttt{INVOKE} as the first frame, and the server responds
        with either \texttt{CONTINUE} (binding succeeded) or a terminal
        \texttt{ERROR} (binding failed).

      \item If HasInS is \texttt{Y} and the RPC initializes successfully, the
        client MAY send zero or more \texttt{IN\_STREAM} frames.

        For any RPC that completes successfully (that is, with a
        \texttt{RESPONSE} and without \texttt{CANCEL}, \texttt{CANCELLED}, or
        \texttt{ERROR}), the client MUST send exactly one \texttt{IN\_CLOSE} for
        that \texttt{CorrelationID}, and the server MUST NOT send
        \texttt{RESPONSE} until it has received that \texttt{IN\_CLOSE}.

        If the RPC is terminated by \texttt{CANCEL}, \texttt{CANCELLED}, or
        \texttt{ERROR}, \texttt{IN\_CLOSE} MUST NOT be sent.  If HasInS is
        \texttt{N}, the client MUST NOT send \texttt{IN\_STREAM} or
        \texttt{IN\_CLOSE} at any time.

      \item If HasOutS is \texttt{Y} and the RPC is initialized successfully,
        the server MAY send zero or more \texttt{OUT\_STREAM} frames.

        For any RPC that completes successfully, the server MUST send exactly
        one \texttt{OUT\_CLOSE} frame for that \texttt{CorrelationID}, and it
        MUST send that \texttt{OUT\_CLOSE} before sending \texttt{RESPONSE}.

        If the RPC is terminated by \texttt{CANCEL}, \texttt{CANCELLED}, or
        \texttt{ERROR}, the server MUST NOT send \texttt{OUT\_CLOSE}.
        Cancellation or error implicitly closes the output stream. If HasOutS
        is \texttt{N}, the server MUST NOT send \texttt{OUT\_STREAM} or
        \texttt{OUT\_CLOSE} at any time.
    \end{itemize}

    Sending a \texttt{RESPONSE} frame for a method form with
    \textbf{HasInputStream} or \textbf{HasOutputStream} set to \texttt{true}
    \emph{before} the required \texttt{IN\_CLOSE} and/or \texttt{OUT\_CLOSE}
    frames have been sent and received (in the successful, non-error,
    non-cancel case) is a protocol error.  Because such an error cannot be
    reliably reported using an \texttt{ERROR} frame scoped to the same
    \texttt{CorrelationID}, implementations SHOULD treat it as a
    connection-level protocol violation and close the underlying transport.

  \subsection{Interleaving of Input and Output Streams}

    For method forms that declare both an input stream and an output
    stream (i.e., \textbf{HasInputStream} = true and
    \textbf{HasOutputStream} = true), the client and server MAY send
    \texttt{IN\_STREAM} and \texttt{OUT\_STREAM} frames in any order,
    including arbitrarily interleaved.  Neither endpoint is required to
    await stream activity from the peer before sending additional
    elements.

    Stream directions are independent: the client MAY continue sending
    input elements regardless of whether the server is actively sending
    output elements, and vice versa.

  \subsection{Unary vs Streaming Semantics}

    \subsubsection{Unary Input}
    \label{sec:unary-input}

      The \texttt{INVOKE} frame layout (identifiers and optional unary inputs)
      is defined in Section~\ref{sec:frame-format}.  This subsection states
      only when the unary input tuple is present: if \textbf{HasInput} is
      \texttt{true}, the unary input tuple is included after the identifiers
      block; if \textbf{HasInput} is \texttt{false}, an empty unary input tuple
      is  encoded. Clients MUST encode a zero-length input tuple even when
      \texttt{HasInput} is \texttt{false}.

    \subsubsection{RPC Completion}
    \label{sec:rpc-completion}

      An RPC is considered to have completed \emph{successfully} if and only if
      it terminates via \texttt{RESPONSE}.

      A \texttt{RESPONSE} frame is a terminal condition only when it is validly
      transmitted, meaning:

      \begin{itemize}
        \item if \textbf{HasInputStream} is \texttt{true}, the client has
          already sent exactly one \texttt{IN\_CLOSE} for that
          \texttt{CorrelationID}; and
        \item if \textbf{HasOutputStream} is \texttt{true}, the server has
          already sent exactly one \texttt{OUT\_CLOSE} for that
          \texttt{CorrelationID}.
      \end{itemize}

      A \texttt{RESPONSE} received in violation of these sequencing rules MUST
      be treated as a protocol error and MUST NOT be considered successful
      completion.

      Any RPC whose lifecycle includes a terminal \texttt{ERROR} frame is
      considered to have completed abnormally, while a terminal
      \texttt{CANCELLED} indicates that the RPC was cancelled by the client.
      The semantics of cancellation on the view-point of RPC method
      implementations is implementation-dependent and out of scope of this
      document.  The only normative direction in cancellation is that the server
      MUST NOT send other frames for the cancelled \texttt{CorrelationID}, and
      MUST employ ways to notify the implementation that the RPC has been
      cancelled, as specified in Section~\ref{sec:cancel-frame} and
      \ref{sec:cancellation}.

      For an RPC that is still active at the server, a client-initiated
      cancellation immediately aborts the execution of the RPC.  The server MUST
      send a single \texttt{CANCELLED} frame, and cease sending any other frames
      for that RPC. More information is contained within
      Section~\ref{sec:cancellation}.

      For a given \texttt{CorrelationID}, an RPC is considered complete, from
      the point of view of a given endpoint, when that endpoint has observed one
      of the following terminal conditions for that endpoint:

      \begin{itemize}
        \item The endpoint has sent or received an \texttt{ERROR} frame for that
          \texttt{CorrelationID}; or
        \item The endpoint has observed either:
          \begin{itemize}
            \item successful unary completion through a \texttt{RESPONSE}
              frame; or
            \item cancellation through a \texttt{CANCELLED} frame.
          \end{itemize}
      \end{itemize}

      Unary completion is directional:

      \begin{itemize}
        \item From the \textbf{client}'s perspective, unary completion occurs
          when it has \emph{received} a \texttt{RESPONSE} frame for the
          \texttt{CorrelationID}.
        \item From the \textbf{server}'s perspective, unary completion occurs
          when it has \emph{sent} a \texttt{RESPONSE} frame for the
          \texttt{CorrelationID}.
      \end{itemize}

      Stream closure is also directional:

      \begin{itemize}
        \item A stream flowing \emph{from the client to the server} (the input
          stream when \textbf{HasInputStream} is \texttt{true}) is considered
          closed:
          \begin{itemize}
            \item by the \textbf{client} when it has \emph{sent} exactly one
              \texttt{IN\_CLOSE} frame; and
            \item by the \textbf{server} when it has \emph{received} exactly one
              \texttt{IN\_CLOSE} frame.
            \item by both if any \texttt{ERROR} or \texttt{CANCELLED} frame is
              exchanged.
          \end{itemize}

        \item A stream flowing \emph{from the server to the client} (the output
          stream when \textbf{HasOutputStream} is \texttt{true}) is considered
          closed:
          \begin{itemize}
            \item by the \textbf{server} when it has \emph{sent} exactly one
              \texttt{OUT\_CLOSE} frame; and
            \item by the \textbf{client} when it has \emph{received} exactly one
              \texttt{OUT\_CLOSE} frame.
            \item by both if any \texttt{ERROR} or \texttt{CANCELLED} frame is
              exchanged.
          \end{itemize}
      \end{itemize}

      Thus, for a \emph{successful} RPC (no \texttt{ERROR} or \texttt{CANCELLED}
      frame), the client considers the RPC complete when it has received
      \texttt{RESPONSE}.  The client MUST consider the RPC as cancelled when
      a \texttt{CANCELLED} frame is received, and MUST consider it failed in
      case an \texttt{ERROR} frame is received.

      Symmetrically, the server considers the RPC terminated when it has sent
      either \texttt{RESPONSE}, \texttt{ERROR}, or \texttt{CANCELLED}.

      A \texttt{CANCEL} frame is not itself a terminal condition; it is a
      control signal that requests termination of the RPC and triggers the
      error semantics described in Section~\ref{sec:cancellation} and
      Section~\ref{sec:error-frames}.

      Once any of the above terminal conditions is satisfied for an endpoint,
      that endpoint MUST treat the corresponding \texttt{CorrelationID} as
      inactive and MUST NOT send any further frames with that
      \texttt{CorrelationID}.

      With the exception of late \texttt{CANCEL} frames (see
      Section~\ref{sec:cancellation}), any frame received for an inactive
      \texttt{CorrelationID} MUST be treated as a protocol error and MUST
      cause the connection to be closed.

      Endpoints MUST NOT reuse a \texttt{CorrelationID} for a new RPC while
      they still consider the existing RPC for that identifier to be active.
      In particular, sending or receiving a \texttt{CANCEL} frame does not, by
      itself, render an RPC complete.  A client that has sent \texttt{CANCEL}
      MUST NOT reuse the corresponding \texttt{CorrelationID} on that
      connection until it has either observed an \texttt{CANCELLED} frame, or
      the appropriate combination of \texttt{RESPONSE} and stream closures or
      closed the underlying transport connection.

    \subsubsection{Unary Output}
    \label{sec:unary-output}

      The on-wire layout of \texttt{RESPONSE} is defined in
      Section~\ref{sec:frame-format}.  For method forms without an output
      stream (\textbf{HasOutputStream} = \texttt{false}), every RPC that
      completes successfully (no \texttt{ERROR}) MUST send exactly one
      \texttt{RESPONSE} for the corresponding \texttt{CorrelationID}, and it
      MUST be the last application-level frame for that RPC.  All ordering and
      closure rules remain unchanged:

      \begin{itemize}
        \item If \textbf{HasOutput} is \texttt{true}, the \texttt{RESPONSE}
          payload contains the unary output tuple with encoded response values;
          otherwise, it contains an empty unary output tuple.  In all legal
          method forms, successful completion is signalled by exactly one
          \texttt{RESPONSE} frame.
        \item If \textbf{HasOutputStream} is \texttt{true}, exactly one
          \texttt{OUT\_CLOSE} MUST be sent before \texttt{RESPONSE}.  No
          \texttt{OUT\_STREAM} or \texttt{OUT\_CLOSE} frames may follow
          \texttt{RESPONSE}.
        \item If \textbf{HasInputStream} is \texttt{true}, the server MUST NOT
          send \texttt{RESPONSE} until it has received exactly one
          \texttt{IN\_CLOSE} for that \texttt{CorrelationID}.
        \item If the RPC terminates via \texttt{CANCELLED} or \texttt{ERROR},
          input and output streams are implicitly closed; \texttt{IN\_CLOSE} and
          \texttt{OUT\_CLOSE} MUST NOT be sent afterward, and \texttt{RESPONSE}
          is not sent.
      \end{itemize}

    \subsubsection{Output Stream}
    \label{sec:output-stream}

      If \textbf{HasOutputStream} is \texttt{true}, the server MAY produce an
      output stream \emph{after} sending the \texttt{CONTINUE} frame.

      In that case, the following rules apply for the given
      \texttt{CorrelationID}:

      \begin{itemize}
        \item The server MAY send zero or more \texttt{OUT\_STREAM} frames.
        \item Each \texttt{OUT\_STREAM} frame MUST contain exactly one
          serialized element of the declared output stream type.
        \item If the RPC completes successfully (that is, with a
          \texttt{RESPONSE} and without \texttt{CANCEL} or \texttt{ERROR}), the
          server MUST send exactly one \texttt{OUT\_CLOSE} frame for that
          \texttt{CorrelationID}, and it MUST send this \texttt{OUT\_CLOSE}
          before the \texttt{RESPONSE} frame.

          If the RPC terminates due to \texttt{CANCEL} or \texttt{ERROR}, the
          server MUST NOT send \texttt{OUT\_CLOSE}.  Cancellation or error
          implicitly closes the output stream.
        \item The server MUST NOT send any \texttt{OUT\_STREAM} or
          \texttt{OUT\_CLOSE} frames after the \texttt{RESPONSE} frame.
        \item After sending \texttt{OUT\_CLOSE}, the server MUST NOT send any
          further \texttt{OUT\_STREAM} or \texttt{OUT\_CLOSE} frames for
          that \texttt{CorrelationID}.
      \end{itemize}

      Thus, for methods with \textbf{HasOutputStream} set to \texttt{true},
      the canonical successful server-side sequence (ignoring input frames)
      is:

      \begin{lstlisting}[language=plain]
CONTINUE
OUT_STREAM*   // zero or more times
OUT_CLOSE
RESPONSE
      \end{lstlisting}

  \subsection{Per-form Examples}

    This subsection provides illustrative but non-normative examples of legal
    frame sequences for selected method forms.  Let \texttt{CID} be a
    \texttt{CorrelationID}.

    \subsubsection{Form: NNNN (no input, no output, no streams)}

      \begin{lstlisting}[language=plain]
INVOKE(CID)
CONTINUE(CID)
RESPONSE(CID)
      \end{lstlisting}

    \subsubsection{Form: NNNY (server-streaming only)}

      \begin{lstlisting}[language=plain]
INVOKE(CID)
CONTINUE(CID)
OUT_STREAM(CID)* // zero or more items
OUT_CLOSE(CID)
RESPONSE(CID)
      \end{lstlisting}

    \subsubsection{Form: YNYN (unary input, input stream, no unary output)}

      \begin{lstlisting}[language=plain]
INVOKE(CID, unary-input)
CONTINUE(CID)
IN_STREAM(CID, T)* // zero or more items
IN_CLOSE(CID)
RESPONSE(CID)   // empty unary output tuple
      \end{lstlisting}

      \noindent

      \textbf{Note:} In the successful case (no \texttt{CANCEL} or
      \texttt{ERROR}), the client MUST eventually close the input stream by
      sending exactly one \texttt{IN\_CLOSE} frame, and the server MUST NOT send
      \texttt{RESPONSE} until it has received that \texttt{IN\_CLOSE}.  The
      server is free to process input elements and decide its unary result as
      soon as it has sufficient information, but it is not permitted to complete
      the RPC on the wire (by sending \texttt{RESPONSE}) before the input stream
      has been explicitly closed.

    \subsubsection{Form: YYNN (Unary only)}

      \begin{lstlisting}[language=plain]
INVOKE
CONTINUE
RESPONSE   // unary output tuple
      \end{lstlisting}

    \subsubsection{Form: NNNY (output stream)}

      \begin{lstlisting}[language=plain]
INVOKE
CONTINUE
OUT_STREAM* // zero or more items
OUT_CLOSE
RESPONSE   // empty unary output tuple
      \end{lstlisting}

    \subsubsection{Form: YNYY (unary input, input stream, output stream, no unary output)}

      \begin{lstlisting}[language=plain]
INVOKE (unary input tuple)
CONTINUE
IN_STREAM*   // zero or more items
OUT_STREAM*  // zero or more items
IN_CLOSE
OUT_CLOSE
RESPONSE   // empty unary output tuple
      \end{lstlisting}

      \noindent

      \textbf{Note:} As stated in other sections, \texttt{IN\_STREAM} and
      \texttt{OUT\_STREAM} may be freely interleaved; consuming and emitting
      items to both streams are left as a client and RPC method implementation
      detail that is out of scope for this specification.

  \subsection{Error and Cancellation Semantics}
  \label{sec:error-and-cancel}

    \subsubsection{Error Frames}
    \label{sec:error-frames}

      An \texttt{ERROR} frame represents terminal failure or non-successful
      termination of an RPC for the associated \texttt{CorrelationID}.  For a
      given \texttt{CorrelationID}:

      \begin{itemize}
        \item At most one \texttt{ERROR} frame MAY be sent per endpoint for a
          given RPC.
        \item Once an endpoint has sent an \texttt{ERROR} frame, it MUST NOT
          send any further frames with that \texttt{CorrelationID}.
        \item Once an endpoint has received an \texttt{ERROR} frame, it MUST
          treat the RPC as terminated and MUST ignore any subsequent frames
          \emph{for that RPC} with that \texttt{CorrelationID}.
      \end{itemize}

      Unless explicitly stated otherwise, any violation of the framing,
      sequencing, or typing rules defined in this specification is a protocol
      error.  Protocol errors are connection-scoped conditions: the receiving
      endpoint MUST treat them as connection-level failures and MUST close the
      underlying transport connection.  Only application-defined failures
      explicitly represented as \texttt{ERROR} payloads are RPC-scoped and MAY
      leave the connection itself intact.

      The RPC error descriptor has the following logical structure:

      \begin{lstlisting}[language=arf]
struct RPCError {
    code    uint32;
    message string;
    details optional<bytes>;
}
      \end{lstlisting}

      The fields have the following semantics:

      \begin{itemize}
        \item \texttt{code} is a numeric error code.  This specification
          reserves the following well-known values:

          \begin{itemize}
            \item \texttt{0}: \textbf{UNKNOWN}.  An unspecified server-side
              failure occurred.
            \item \texttt{1}: \textbf{UNKNOWN\_METHOD}.  The RPC was rejected
              because the server could not find a method to bind the call.
          \end{itemize}

          Additional code values MAY be defined by implementations and
          application profiles.

        \item \texttt{message} is a human-readable diagnostic string intended
          for logging and debugging.  It MUST NOT be relied on for programmatic
          behavior.

        \item \texttt{details} is an optional opaque blob that MAY carry
          application-specific structured information (for example, a serialized
          domain-specific error structure).  Its interpretation is entirely
          out-of-band and MAY vary between deployments.
      \end{itemize}

      Implementations SHOULD attempt to decode any non-empty \texttt{ERROR}
      payload as \texttt{RPCError}.  If decoding fails, the receiver MUST still
      treat the \texttt{ERROR} frame as a terminal condition for the RPC and MAY
      surface a generic error to the application.

      The existence, absence, or contents of an \texttt{ERROR} payload MUST NOT
      affect the framing, completion, or cancellation rules defined elsewhere in
      this specification.

      The \texttt{ERROR} frame is scoped to a single RPC identified by its
      \texttt{CorrelationID}.  Some classes of protocol violations are
      therefore not safely expressible via \texttt{ERROR}.  In particular,
      if an endpoint receives a second \texttt{INVOKE} frame for a
      \texttt{CorrelationID} that it still considers active, it cannot
      safely emit an \texttt{ERROR} for that \texttt{CorrelationID} without
      risking misassociation with the original RPC.  Such conditions MUST be
      treated as connection-level protocol errors: implementations MUST
      close the transport connection and MUST NOT attempt to report them
      using \texttt{ERROR}.

    \subsubsection{Cancellation}
    \label{sec:cancellation}

      A client MAY request an ongoing RPC to be aborted using a \texttt{CANCEL}
      frame with the same \texttt{CorrelationID} as the active call.
      A \texttt{CANCEL} frame MUST carry an empty payload; its
      \texttt{PayloadLength} field MUST be zero.

      Cancellation is scoped to a single RPC. A \texttt{CANCEL} frame affects
      only the RPC identified by its \texttt{CorrelationID}; it MUST NOT alter
      the state or progression of any other active RPCs multiplexed on the same
      connection.

      Upon receiving a \texttt{CANCEL} frame for an \emph{active} RPC (that is,
      one for which the completion conditions in
      Section~\ref{sec:rpc-completion} have not yet been satisfied), the
      server must notify the executor of the intention of the client to cancel
      the RPC.  The executor then SHOULD handle the signal accordingly.

      Once a \texttt{CANCEL} frame is received for an \emph{active} RPC, the
      server MUST respond with a single \texttt{CANCELLED} frame, and cease
      sending any other frame for the same \texttt{CorrelationID}.  Any RPC's
      attempts to send new frames MUST be reported as an error to the executor.

      If the server receives a \texttt{CANCEL} frame for a
      \texttt{CorrelationID} that it already considers inactive (because the
      RPC has completed according to Section~\ref{sec:rpc-completion}), it
      MUST treat the \texttt{CANCEL} as a late control signal, MUST NOT send
      any additional frames (including \texttt{ERROR} or \texttt{CANCELLED}) in
      response, and MUST NOT treat the late \texttt{CANCEL} as a protocol error
      solely by virtue of its lateness.

      A client that sends \texttt{CANCEL}:

      \begin{itemize}
        \item MUST NOT treat the RPC as terminated for local application
          purposes immediately after sending \texttt{CANCEL}.  Cancellation is
          only confirmed after a \texttt{CANCELLED} frame is received.
        \item MUST NOT reuse the \texttt{CorrelationID} for a new RPC on that
          connection until it has either observed a terminal condition as
          defined in Section~\ref{sec:rpc-completion} or closed the underlying
          transport connection; and
        \item MUST ignore any subsequently received application-level
          frames until the terminal \texttt{CANCELLED} acknowledgement.
      \end{itemize}

      If a \texttt{CANCEL} frame is received for an RPC that has already
      completed, the receiver MUST ignore the frame and MUST NOT respond
      with an \texttt{ERROR} or \texttt{CANCELLED}.

      Sending \texttt{CANCELLED} implicitly closes the input stream and/or
      output stream, if any are currently open.  No \texttt{IN\_CLOSE} or
      \texttt{OUT\_CLOSE} frames are required or permitted after cancellation.

  \subsection{Backpressure}

    arf does not define a mandatory flow-control mechanism.  Implementations
    SHOULD apply backpressure using transport-level or application-level
    means.  Implementations MUST remain robust in the presence of senders
    that produce data more rapidly than the receiver can process.

    Extensions to provide explicit credit-based flow control MAY be defined
    in future versions of this specification.

\section{Evolution and Compatibility}
\label{sec:evolution}

  arf is designed to permit incremental schema evolution without requiring
  explicit field identifiers in source files.  Compatibility is achieved by
  combining stable field ordinals with length-prefixed struct encoding, allowing
  new fields to be added while preserving the ability of older implementations
  to safely skip unknown data.

  The rules in this section govern how types may change across package versions
  while maintaining compatibility at the binary level.

 \subsection{Adding Fields}

    New fields MAY be appended to the end of an existing struct.  Because field
    ordinal indices are defined by declaration order, appending a field assigns
    it the next available ordinal.  Existing ordinals MUST NOT change.

    Struct values are length-prefixed as defined in
    Section~\ref{sec:serialization}.  As a result, receivers MUST skip any
    trailing bytes in the struct body beyond the fields they recognize.  This
    allows new fields to be introduced in a backward-compatible and
    forward-compatible manner.

    Senders MAY include newly added fields when communicating with older
    receivers; older receivers MUST ignore trailing bytes safely.  Likewise,
    senders MAY omit fields not known to the peer.

    New fields SHOULD be declared as \texttt{optional<T>} unless the semantics
    require mandatory presence.  Using \texttt{optional<T>} maximizes flexibility
    and minimizes compatibility risk.

  \subsection{Removing Fields}

    Fields MUST NOT be removed from a struct in a way that changes the ordinal
    position of any remaining field.  Instead, fields that are no longer used
    SHOULD be marked with the \texttt{@deprecated} attribute and retained with
    their original ordinal position.

    Senders SHOULD omit deprecated fields when serializing.  Receivers MUST
    accept and SHOULD ignore deprecated fields if they appear.

    If a field must be fully removed (such that its ordinal becomes invalid),
    this MUST be done only by introducing a new package version (see
    Section~\ref{sec:versioning}).  No cross-package compatibility is required.

  \subsection{Changing Types}

    A field's type MUST NOT change within the same package version.  Any
    modification to a field's type, including widening (e.g., \texttt{int32} to
    \texttt{int64}), narrowing, or structural change, constitutes a
    backward-incompatible change.

    Type changes MUST be performed only by introducing a new package version.

    Changing a field from a concrete type to \texttt{optional<T>} within the
    same package version is permitted only if:
    \begin{itemize}
      \item the wire encoding is identical when the value is present, and
      \item receivers can safely interpret the absence of the value as ``not
        present''.
    \end{itemize}

    Changing a field from \texttt{optional<T>} to a non-optional type is not
    compatible and MUST NOT be performed within the same package version.

  \subsection{Versioning Through Packages}
  \label{sec:versioning}

    arf relies on the \texttt{package} namespace as the primary unit of
    versioning.  A change that violates any of the compatibility rules in
    this section MUST be introduced under a new package name.

    Package names SHOULD include a stability level (e.g.,
    \texttt{v1beta1}, \texttt{v1}, \texttt{v2}) to provide clear evolution
    points.  Implementations MAY simultaneously support multiple package
    versions.

    No cross-package binary compatibility is required or implied.  Changes
    within a package version MUST adhere to the evolution rules above.

\section{ABNF Grammar}

  This section provides the normative syntax of the arf source language,
  expressed using Augmented Backus–Naur Form (ABNF) as defined in
  RFC~5234 and RFC~7405.  ABNF rules specify the lexical and syntactic
  structure of valid arf source files.  The grammar below is complete
  for this specification.

\begin{quote}
  \small
  \VerbatimInput{grammar.abnf}
\end{quote}

\section{Security Considerations}

  arf describes a serialization format and an RPC protocol but does not
  mandate any particular transport security mechanism.  When deployed over
  an untrusted network, implementations MUST provide confidentiality,
  integrity, and endpoint authentication using a transport such as TLS
  \cite{RFC8446}, QUIC \cite{RFC9000} with TLS 1.3 \cite{RFC9001}, or an
  equivalent secure channel.

  Endpoints MUST validate that incoming frames conform to the arf framing
  rules, including length fields, frame ordering constraints, and stream
  termination semantics. Malformed or truncated frames MUST be treated as
  protocol errors: they MUST result in termination of the associated
  \texttt{CorrelationID} and MUST cause the underlying connection to be
  closed, as described in Section~\ref{sec:error-frames}.

  Implementations MUST impose limits on:
  \begin{itemize}
    \item maximum frame length,
    \item maximum number of concurrent \texttt{CorrelationID} streams,
    \item maximum nesting depth for type decoding,
    \item maximum aggregate memory per connection.
  \end{itemize}

  These limits prevent resource exhaustion attacks.

  Optional fields and variable-length structures (arrays, maps, byte
  sequences) MUST be validated before allocation.  Implementations MUST
  reject encodings that imply unreasonable memory commitments.

  Method names, package names, and type names are not security boundaries.
  Applications MAY impose authorization checks based on method identity,
  but such checks are outside the scope of this specification.

  Applications that embed sensitive data in arf messages MUST consider
  application-level encryption or tokenization if end-to-end confidentiality
  is required beyond the transport layer.

\section{IANA Considerations}

  This document makes no requests of the IANA.

  Future versions of arf MAY define frame-type registries or well-known
  package namespaces.  Such extensions MUST define their own IANA
  interactions as appropriate.

\section{References}
\printbibliography[heading=none,resetnumbers=true]

\section{Acknowledgements}

  The author thanks the contributors to early discussions on arf's design,
  particularly those who provided feedback on streaming semantics, package
  versioning, and binary framing constraints.

  The structure and terminology of this document were influenced by the
  style of the IETF and prior work on schema-based RPC systems, including
  Protocol Buffers, Cap’n Proto, and Thrift.

\section{Appendices}
\appendix

  \section{FNV-1a-32 Reference Implementation}
  \label{annex:a}

    \begin{lstlisting}[language=arfC]
#define ARF_FNV1A32_OFFSET 0x811C9DC5u
#define ARF_FNV1A32_PRIME  0x01000193u

/* Compute FNV-1a over an arbitrary byte sequence. */
uint32_t arf_fnv1a32(const uint8_t *data, size_t len) {
    uint32_t h = ARF_FNV1A32_OFFSET;

    for (size_t i = 0; i < len; i++) {
        h ^= (uint32_t)data[i];
        h *= ARF_FNV1A32_PRIME;  /* 32-bit unsigned wraparound */
    }

    return h;
}

/* Convenience helper for NUL-terminated UTF-8 strings. */
uint32_t arf_fnv1a32_cstr(const char *s) {
    const uint8_t *p = (const uint8_t *)s;
    uint32_t h = ARF_FNV1A32_OFFSET;

    while (*p) {
        h ^= (uint32_t)*p++;
        h *= ARF_FNV1A32_PRIME;
    }

    return h;
}
    \end{lstlisting}

  \section{FNV-1a-32 Test Vectors (Informative)}
  \label{annex:b}

      This annex provides test vectors for the 32-bit FNV-1a hash function
      used by arf.  All strings are encoded as UTF-8 without a terminating
      NUL byte unless otherwise noted.

      \begin{center}
        \begin{tabular}{@{}ll@{}}
            \toprule
            Input string                & FNV-1a-32 output \\ \midrule
            (empty string)              & \texttt{0x811C9DC5} \\
            \texttt{"a"}                & \texttt{0xE40C292C} \\
            \texttt{"b"}                & \texttt{0xE70C2DE5} \\
            \texttt{"foobar"}           & \texttt{0xBF9CF968} \\
            \texttt{"pkg:v1beta1.common"} &
              \texttt{0xF746E480} \\
            \texttt{"svc:v1beta1.common.TimestampService"} &
              \texttt{0xEAA88025} \\
            \texttt{"method:v1beta1.common.TimestampService.GetTimestamp"} &
              \texttt{0x01015F42} \\
            \bottomrule
        \end{tabular}
      \end{center}

      Implementations SHOULD verify their FNV-1a-32 implementation against
      these test vectors before using it to derive \texttt{PackageID},
      \texttt{ServiceID}, or \texttt{MethodID} values.

  \section{C Reference Implementation for ZigZag Encoding}
  \label{annex:zigzag}

    The following C code implements ZigZag transformation for 32-bit and 64-bit
    signed integers.

    \begin{lstlisting}[language=arfC]
/* Encode signed 32-bit integer into ZigZag form. */
static inline uint32_t arf_zigzag32_encode(int32_t n) {
    return (uint32_t)(((uint32_t)n << 1) ^ (uint32_t)(n >> 31));
}

/* Decode ZigZag-encoded 32-bit integer. */
static inline int32_t arf_zigzag32_decode(uint32_t z) {
    return (int32_t)((z >> 1) ^ (uint32_t)-(int32_t)(z & 1u));
}

/* Encode signed 64-bit integer into ZigZag form. */
static inline uint64_t arf_zigzag64_encode(int64_t n) {
    return (uint64_t)(((uint64_t)n << 1) ^ (uint64_t)(n >> 63));
}

/* Decode ZigZag-encoded 64-bit integer. */
static inline int64_t arf_zigzag64_decode(uint64_t z) {
    return (int64_t)((z >> 1) ^ (uint64_t)-(int64_t)(z & 1u));
}
    \end{lstlisting}

  \section{Test Vectors for Signed Integer Encoding}
  \label{annex:testvectors}

    The following test vectors are normative.  Implementations \emph{MUST}
    produce exactly the given ZigZag and VarUInt results.

    \subsection{Common Values}

      \begin{center}
        \begin{tabular}{rrrr}
          \toprule
          Value & ZigZag($n$) & Decimal & VarUInt Encoding \\ \midrule
          0     & 0x00        & 0       & \texttt{00} \\
          -1    & 0x01        & 1       & \texttt{01} \\
          1     & 0x02        & 2       & \texttt{02} \\
          -2    & 0x03        & 3       & \texttt{03} \\
          2     & 0x04        & 4       & \texttt{04} \\
          63    & 0x7E        & 126     & \texttt{7E} \\
          -64   & 0x7F        & 127     & \texttt{7F} \\
          64    & 0x80        & 128     & \texttt{80 01} \\
          -65   & 0x81        & 129     & \texttt{81 01} \\
          300   & 0x0258      & 600     & \texttt{D8 04} \\
          -300  & 0x0257      & 599     & \texttt{D7 04} \\
          \bottomrule
        \end{tabular}
      \end{center}

    \subsection{Boundary Values}

      \subsubsection{int8}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            -128  & 0xFF        & \texttt{FF 01} \\
            127   & 0xFE        & \texttt{FE 01} \\
            \bottomrule
          \end{tabular}
        \end{center}

      \subsubsection{int16}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            -32768 & 0xFFFF     & \texttt{FF FF 03} \\
            32767  & 0xFFFE     & \texttt{FE FF 03} \\
            \bottomrule
          \end{tabular}
        \end{center}

      \subsubsection{int32}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            -2147483648 & 0xFFFFFFFF & \texttt{FF FF FF FF 0F} \\
            2147483647  & 0xFFFFFFFE & \texttt{FE FF FF FF 0F} \\
            \bottomrule
          \end{tabular}
        \end{center}

      \subsubsection{int64}

        \begin{center}
          \begin{tabular}{rrr}
            \toprule
            Value & ZigZag($n$) & VarUInt Bytes \\ \midrule
            INT64\_MIN & 0xFFFFFFFFFFFFFFFF & \texttt{FF FF FF FF FF FF FF FF FF 01} \\
            INT64\_MAX & 0xFFFFFFFFFFFFFFFE & \texttt{FE FF FF FF FF FF FF FF FF 01} \\
            \bottomrule
          \end{tabular}
        \end{center}

\section{Implementation Notes (Informative)}
\label{annex:impl-notes}

  This appendix provides non-normative guidance for implementers of arf
  encoders, decoders, and RPC runtimes.  The recommendations in this section
  are intended to improve robustness, interoperability, and operational
  safety, but they do not introduce additional protocol requirements beyond
  the normative text in the main body of this specification.

  \subsection{Recommended Limits}

    Although the core specification does not mandate concrete numeric limits,
    practical implementations SHOULD enforce the following upper bounds:

    \begin{itemize}
      \item \textbf{Maximum frame size}: Implementations SHOULD bound the
        size of a single arf frame (including header and payload).  A value
        on the order of 1--16~MiB is typical for RPC-style workloads, but
        deployments MAY choose tighter or looser limits based on use case.
      \item \textbf{Maximum struct body size}: Independently from the frame
        limit, implementations SHOULD bound the decoded struct body length
        (the \texttt{VarUInt(L)} prefix for a struct).  This prevents a
        malicious peer from embedding an excessively large struct within an
        otherwise reasonable frame.
      \item \textbf{Maximum nesting depth}: Decoders SHOULD enforce a maximum
        nesting depth for composite types (e.g., structs containing arrays of
        structs containing maps, and so on).  A depth limit on the order of
        32--64 is generally sufficient to prevent stack exhaustion in
        recursive decoders.
      \item \textbf{Maximum collection lengths}: Implementations SHOULD
        impose limits on:
        \begin{itemize}
          \item maximum array length,
          \item maximum map entry count,
          \item maximum string length (in bytes),
          \item maximum \texttt{bytes} length.
        \end{itemize}
        These limits SHOULD be enforced before allocating memory for the
        collection payload.
      \item \textbf{Maximum concurrent RPCs}: Servers SHOULD bound the number
        of simultaneously active \texttt{CorrelationID} values per
        connection, and MAY apply per-principal or per-IP concurrency limits
        at a higher layer.
    \end{itemize}

    Implementations SHOULD treat the violation of such local limits as a
    fatal error for the affected RPC, and MAY close the underlying
    connection if abuse is suspected.

  \subsection{VarUInt and Signed Integer Decoding}

    Implementations SHOULD adopt the following practices when decoding
    \texttt{VarUInt} and ZigZag-encoded integers:

    \begin{itemize}
      \item \textbf{Byte limit}: For 64-bit values, at most ten bytes are
        needed to represent any valid \texttt{VarUInt}.  Decoders SHOULD
        reject encodings that use more than ten bytes, even if the resulting
        numeric value would still fit in a 64-bit unsigned integer.
      \item \textbf{Early overflow detection}: When reconstructing the
        integer value, decoders SHOULD detect overflow incrementally (for
        example, before shifting or adding each new 7-bit chunk) rather than
        relying on native wraparound.
      \item \textbf{Width checking}: After applying ZigZag decoding,
        implementations MUST verify that the result falls within the range
        of the declared signed type (as specified in
        Section~\ref{sec:signed-int-encoding}).  Implementers are encouraged
        to centralize these checks in shared helpers to avoid inconsistencies
        across call sites.
    \end{itemize}

    For encoder implementations, it is RECOMMENDED to reuse the same
    \texttt{VarUInt} and ZigZag routines across all integer types to ensure
    uniform behavior and simplify testing.

  \subsection{Framing and Buffering Strategies}

    Because arf frames are carried over a reliable byte stream, endpoints
    MUST reconstruct frames from arbitrary segment boundaries.  In practice,
    many implementations adopt one of the following patterns:

    \begin{itemize}
      \item Maintain a per-connection read buffer, append bytes as they are
        received, and attempt to parse complete frames in a loop until no
        further complete frame is available.
      \item Use a small state machine that first parses the fixed header,
        then decodes \texttt{PayloadLength} using \texttt{VarUInt}, and
        finally waits until the indicated number of payload bytes are
        available before dispatching the frame.
    \end{itemize}

    Implementations SHOULD validate the \texttt{Magic} and \texttt{Version}
    fields before allocating large buffers for the payload.  If either field
    is invalid, the connection SHOULD be closed immediately.

  \subsection{Stream and RPC Lifecycle Management}

    Implementers are encouraged to model each active RPC as an explicit
    state machine keyed by \texttt{CorrelationID}.  Such a state machine
    typically tracks:

    \begin{itemize}
      \item whether \texttt{INVOKE} has been seen,
      \item whether \texttt{RESPONSE} has been sent or received,
      \item whether the input stream (if any) is open or closed,
      \item whether the output stream (if any) is open or closed,
      \item whether an \texttt{ERROR} or \texttt{CANCEL} has terminated the
        RPC.
    \end{itemize}

    Once the RPC completion conditions in Section~\ref{sec:rpc-completion}
    are satisfied, the corresponding state MUST be discarded and the
    \texttt{CorrelationID} returned to the pool of available identifiers.

    To avoid resource leaks, implementations SHOULD apply inactivity
    timeouts to RPCs that do not progress (for example, an input stream that
    never sends \texttt{IN\_CLOSE}, or a server that never produces
    \texttt{RESPONSE}).  Exceeding such a timeout MAY result in an
    \texttt{ERROR} frame and/or connection closure.

  \subsection{Timestamps and Clock Handling}

    arf \texttt{timestamp} values represent milliseconds since the UTC Unix
    Epoch.  The following practices are RECOMMENDED:

    \begin{itemize}
      \item Timestamps SHOULD be generated based on a monotonic, reasonably
        accurate system clock synchronized via a time protocol such as NTP
        or equivalent.
      \item When converting between local time and UTC, implementations
        SHOULD use a time-zone aware library rather than hard-coding
        offsets, in order to correctly handle daylight saving changes and
        historical time-zone adjustments.
      \item When a platform cannot represent millisecond precision, it
        SHOULD truncate fractional milliseconds toward zero when encoding,
        as described in the core specification.
    \end{itemize}

    When comparing timestamps originating from different systems,
    applications SHOULD be tolerant to moderate clock skew and SHOULD avoid
    treating small discrepancies as protocol errors.

  \subsection{Identifier Caching}

    Because FNV-1a identifier derivation is deterministic and depends only
    on fully-qualified names and fixed prefixes, implementations MAY cache
    the resulting \texttt{PackageID}, \texttt{ServiceID}, and
    \texttt{MethodID} values to avoid recomputing them at runtime.

    Typical approaches include:

    \begin{itemize}
      \item precomputing identifiers at code-generation time and emitting
        them as constants in generated stubs, or
      \item computing identifiers once at process start and storing them in
        an immutable lookup table keyed by fully-qualified name.
    \end{itemize}

    Regardless of caching strategy, compilers and build tooling MUST still
    detect collisions during schema compilation, as specified in
    Section~\ref{sec:identifiers}.

  \subsection{Error Mapping and Diagnostics}

    arf defines a structured error payload format for \texttt{ERROR} frames
    via the \texttt{RPCError} descriptor (Section~\ref{sec:error-frames}).
    This structure provides a machine-readable error code, a human-readable
    message, and optional opaque details.

    Implementations SHOULD define internal error categories and map them onto
    \texttt{RPCError} as follows:

    \begin{itemize}
      \item transport-level failures (e.g., I/O errors, broken connections)
        SHOULD generally result in connection closure rather than an
        \texttt{ERROR} frame, as the framing layer is no longer reliable;
      \item framing- and decoding-level errors that occur \emph{after} a valid
        frame boundary has been established MAY be mapped to an
        \texttt{ERROR} frame if the connection remains otherwise usable;
      \item application-level failures SHOULD be reported via structured
        \texttt{RPCError} values with implementation-defined codes and
        messages.
    \end{itemize}

    Implementations SHOULD use the \texttt{RPCError.details} field sparingly
    and only for optional, diagnostic data that is safe to expose.  This field
    MAY carry structured, application-specific error information encoded out
    of band, but no interoperability is implied unless both peers explicitly
    agree on its format.

    Error messages are intended for human diagnostics and logging only and
    MUST NOT be relied upon for programmatic behavior.

    If an \texttt{ERROR} frame is received with an unparseable or malformed
    payload, the receiver MUST still treat the frame as terminal for the RPC
    and MAY surface a generic failure to the application.
\end{document}
